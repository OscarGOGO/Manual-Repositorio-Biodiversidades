[{"path":"index.html","id":"biodiversidades","chapter":"Biodiversidades","heading":"Biodiversidades","text":"En este manual de prueba se documenta parte del backend de Biodiversidades","code":""},{"path":"git.html","id":"git","chapter":"1 Git","heading":"1 Git","text":"","code":""},{"path":"git.html","id":"instalar-git-y-configurar","chapter":"1 Git","heading":"1.1 Instalar git y configurar","text":"1. Crear cuenta en GitLab o GitHub2. Instalar Git: https://git-scm.com/3. Abrir Git bash4. Configurar Usename escribiendo:git config –-global user.name \"tu user name\"5. Configurar correo escribiendo:git config –-global user.email \"tu user email\"6. Corroborar que se grabó el user name y correo con (Si se necesita puedes salir escribiendo laletra q y enter):git config –-list","code":""},{"path":"git.html","id":"git-gitlab-y-rstudio","chapter":"1 Git","heading":"1.2 Git, GitLab y RStudio","text":"1. Abrimos RStudio2. Nos dirigimos la pestaña de Tools -> Global options -> Git/SVN 3. Generamos una llave SSH (Solo se necesita hacer una ocasión) y la copiamos4. Abrimos GitLab y nos dirigimos Preferences o User settings -> SSH Keys 5. Pegamos el código anterior en la opción key6. Le damos un título y retiramos la fecha de expiración. /7. Finalmente, damos click en Add Key","code":""},{"path":"gitlab-github.html","id":"gitlab-github","chapter":"2 GitLab GitHub","heading":"2 GitLab GitHub","text":"","code":""},{"path":"gitlab-github.html","id":"generar-nuevo-proyecto-gitlab-o-repositorio-github","chapter":"2 GitLab GitHub","heading":"2.1 Generar nuevo proyecto (GitLab) o repositorio (GitHub)","text":"1. GitLab, crear nuevo repositorio.\nPaso 1. Crear nuevo repositorio en GitLab2. Configurar proyecto o repositorioSe deben considerar al menos 4 cosas:Nombre (obligatorio)Nombre (obligatorio)Privacidad (obligatorio)Privacidad (obligatorio)Readme (opcional)Readme (opcional)Click crear :PClick crear :PPaso 2. GitLab","code":""},{"path":"gitlab-github.html","id":"crear-proyecto-en-rstudio","chapter":"2 GitLab GitHub","heading":"2.2 Crear proyecto en RStudio","text":"1. En GitLab o GitHub debes clonar el repositorio en tu maquina haciendo Click en clone2. Copiar el código de SSH o HTTPS.3. Abrir RStudio4. Crear nuevo proyecto 5. Seleccionar Version control6. Seleccionar Git 7. Pegar en Repository URL el código SSH o HTTPS de GitLab, dar un nombre y seleccionar subdirectorio Ver pestaña de Git","code":""},{"path":"gitlab-github.html","id":"push","chapter":"2 GitLab GitHub","heading":"2.3 PUSH","text":"1. Crear un nuevo archivo de R y colocar cualquier cosa, por ejemplo, crear el script de R test.RVer pestaña de GitEl archivo test.R aparece en la pestaña Git. Ahora daremos click en CommitSe despliega una nueva ventana. Seleccionar los archivos que se buscan subir o actualizar en el repositorio de GitLab y marcar (Stage). Escribir un mensaje (Commit message) y hacer click en PushVer pestaña de GitVer pestaña de GitVer pestaña de GitVer pestaña de Git","code":""},{"path":"gitlab-github.html","id":"pull","chapter":"2 GitLab GitHub","heading":"2.4 PULL","text":"1. Abrimos el repositorio de GitLab 2. Editamos el archivo test.RSeleccionar editor y dar clickAgregamos algún comando o texto3. Hacemos un comentario en Commit messages y damos click en Commit changes4. Regresamos nuestro proyecto en RStudio y buscamos nuestra ventana con la pestaña Git que por lo general es la superior derecha.5. Damos click en Pull6. Podemos ver los cambios haciendo click en Diff o en Commit seguido de Changes:\n","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-repositorio.html","id":"organización-de-documentos-y-carpetas-en-el-repositorio","chapter":"3 Organización de documentos y carpetas en el repositorio","heading":"3 Organización de documentos y carpetas en el repositorio","text":"Este repositorio se puede usar para la generación de tablas, vectores, raster, etc. que sirven principalmente de entrada para las gráficas en la plataforma Biodiversidades.En el repositorio se incluyen entradas, scripts y salidas para el tablero de datos y el tablero geoespacial.Probablemente los usuarios más frecuentes del repositorio sean las personas que programen en la SEE, es por eso que sería de gran valía sugerir un arreglo de archivos y carpetas del repositorio. Si el repositorio y su arreglo se realiza por parte de un externo sería bueno considerar las sugerencias aquí propuestas.Se sugiere que las carpetas y archivos tengan un órden jerárquico y que los nombres de las carpetas inicien con una numeración dos dígitos y guión bajo (p. ej., 00_, 01_, 02_) seguido de nombres cortos, sin espacios y sin acentos.continuación, se enumeran algunas de las sugerencias de arreglo en repositorio:Cuatro carpetas principales, 00_Admin, 01_Entradas, 02_Scripts, 03_Salidas.La carpeta 00_Admin contiene información general que puede ser relevante para entender los archivos de entrada. Los archivos pueden ser, por ejemplo, presentaciones, metadatos de insumos, metadatos de scripts, pruebas, documentos, archivos README, etc. Debido las limitaciones de almacenamiento en los administradores de repositorios se sugiere incorporar archivos de gran tamaño; los archivos de gran tamaño pueden destinarse la carpeta de trabajo en el disco e$(\\gap) (Ver siguiente sección).La carpeta 01_Entradas contiene las subcarpetas 01_Funciones y 02_Temporales.La subcarpeta 01_Funciones contiene funciones de R (formatos: .R, .RData o .rds que se ejecutan con source()) que son usados comúnmente en los scripts de diversas secciones de la plataforma (p.ej., archivo de R que contiene las funciones de consulta al SNIB que se usan en varios indicadores). Mientras que en la subcarpeta 02_temporales se encuentran archivos temporales (archivos vectoriales, raster, tablas o funciones) que son de gran tamaño y que son de utilidad para correr de forma fluida los scripts de R. Los archivos de gran tamaño se recomienda alojarlos en la carpeta de trabajo en el disco e$(\\gap) (Ver sección 4).La carpeta 02_Scripts tiene dos subcarpetas que corresponden al Tablero de datos (01_Tablero_datos) y al Tablero geoespacial (02_Tablero_geoespacial). Dentro de cada carpeta existe un archivo .R o script (“Leader”) con las líneas de código necesarias para el procesamiento de todos los elementos/indicadores que permiten obtener las salidas para implementar los gráficos o mapas de los tableros. Para correr los scripts de los temas basta con usar la función source() (para obtener más información consultar la presentación Arreglo jerárquico).En las subcarpetas 01_Tablero_datos y 02_Tablero_geoespacial, se integran otras cuatro carpetas que corresponden los cuatro grandes temas de la plataforma BiodiversidadES (01_Conocimiento, 02_Cambio_global, 03_Avances_hacia_sustentabilidad, 04_Escenarios).La carpeta 03_Salidas contiene las salidas de los scripts de R contenidos en la carpeta 02_Scripts. Los formatos de salida serán acordados con el programador de la plataforma BriodiversidadES, sin embargo, los formatos más usuales son vectoriales, tablas e imágenes. La carpeta 03_Salidas contiene dos subcarpetas que corresponden al Tablero de datos (01_Tablero_datos) y al Tablero geoespacial (02_Tablero_geoespacial). Cada carpeta contiene cuatro carpetas que corresponden los cuatro grandes temas de la plataforma BiodiversidadES y su vez estas cuatro carpetas contienen carpetas con el nombre de las secciones.","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-repositorio.html","id":"ventajas","chapter":"3 Organización de documentos y carpetas en el repositorio","heading":"3.0.1 Ventajas","text":"Tenemos un script principal (00_Lider_) que tiene las condicionales y funciones generales guardadas en archivos .R y que se corren como sourcesTenemos un script principal (00_Lider_) que tiene las condicionales y funciones generales guardadas en archivos .R y que se corren como sourcesCada source corresponde una secciónCada source corresponde una secciónCada source tiene cientos de líneas que se pueden trabajar de forma independienteCada source tiene cientos de líneas que se pueden trabajar de forma independienteSe evita tener un único script con miles de líneas difícil de manejarSe evita tener un único script con miles de líneas difícil de manejar","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-dico-duro-gap.html","id":"organización-de-documentos-y-carpetas-en-el-dico-duro-gap","chapter":"4 Organización de documentos y carpetas en el dico duro $(\\gap)","heading":"4 Organización de documentos y carpetas en el dico duro $(\\gap)","text":"En la carpeta BiodiversidadES en $(\\gap) (.e., L:\\BiodiversidadES) se incluye toda la información necesaria para correr los scripts de R albergados en el repositorio BiodiversidadES. También puede incluir documentación para entender los insumos (p.ej., archivos README)y versiones anteriores de los códigos de R. La carpeta BiodiversidadES contiene cuatro carpetas que corresponden los cuatro temas de la plataforma y su vez estas cuatro carpetas contienen carpetas con el nombre de las secciones.Cada sección tiene carpetas cuyo nombre se relaciona al formato o tipo de archivos que contiene: 01_Vectorial, 02_Raster, 03_Tabla, 04_Funciones, 05_Temporales, 06_Scripts.Ejemplo de arreglo final de carpetas en $(\\gap):NOTA. Puedes agregar más subcarpetas respetando el orden jerárquico, por ejemplo: 06_Imagenes","code":""},{"path":"loops-en-r.-funciones-base-de-r.html","id":"loops-en-r.-funciones-base-de-r","chapter":"5 Loops en R. Funciones base de R","heading":"5 Loops en R. Funciones base de R","text":"(‘“Looping”, “cycling”, “iterating” just replicating instructions’)Trabajaremos con conjunto de datos llamada iris, la base tiene información sobre el largo y ancho de sépalos y pétalos de 50 flores de tres especies de plantas.","code":"\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"apply","chapter":"5 Loops en R. Funciones base de R","heading":"5.1 apply()","text":"Aplicas instrucciones filas o columnas de un data.frame o matriz.Si queremos estimar la media de cada una de mis cuatro variables de la tabla iris entonces podría usar lo siguiente:oooPero podríamos usar apply()¿Porqué sale error o NA?Para ir tomando ritmo resolvamos los siguientes ejercicios:1) Ahora quiero la raíz cuadrada de la media que previamente es elevada la 5ta potencia2) El resultado de la raíz cuadrada la quiero multiplicar por 15 y dividir entre 23) Si el resultado es mayor 1000 que devuelva un 0","code":"\nmean(iris$Sepal.Length)## [1] 5.843333\nmean(iris$Sepal.Width)## [1] 3.057333\nmean(iris$Petal.Length)## [1] 3.758\nmean(iris$Petal.Width)## [1] 1.199333\nc(mean(iris$Sepal.Length), mean(iris$Sepal.Width), mean(iris$Petal.Length), mean(iris$Petal.Width))## [1] 5.843333 3.057333 3.758000 1.199333\ncolMeans(iris[,1:4])## Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n##     5.843333     3.057333     3.758000     1.199333\napply(iris, 2, mean)## Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n## returning NA\n\n## Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n## returning NA\n\n## Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n## returning NA\n\n## Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n## returning NA\n\n## Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n## returning NA## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n##           NA           NA           NA           NA           NA\napply(iris[,1:4], 2, function(x){\n  x.1 <- sqrt(mean(x)^5)\n})## Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n##    82.537565    16.343948    27.377383     1.575251"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"for","chapter":"5 Loops en R. Funciones base de R","heading":"5.2 for()","text":"Sirve para repetir n veces una o más instrucciones. La estructura es:En el siguiente ejemplo usaremos () para obtener un boxplot para cada variable de pétalo y sépalo.Solución 1.Solución 2.Además, podemos crear vectores, listas o data.frames, pero previamente debemos crear un objeto que va almacenar nuestra salida de cada iteración (repetición de instrucciones) y que debe tener las propiedades que queremos de salida.VectorData.frameListaPara colapsar la lista en un unico objeto podemos usar la función .call()","code":"\npar(mfrow=c(2,2))\nboxplot(iris$Sepal.Length ~ iris$Species, ylab = \"Sepal.Length\",\n        xlab = \"Specie\")\nboxplot(iris$Sepal.Width ~ iris$Species, ylab = \"Sepal.Width\",\n        xlab = \"Specie\")\nboxplot(iris$Petal.Length ~ iris$Species, ylab = \"Petal.Length\",\n        xlab = \"Specie\")\nboxplot(iris$Petal.Width ~ iris$Species, ylab = \"Petal.Width\",\n        xlab = \"Specie\")\npar(mfrow=c(2,2))\nfor(i in 1:4){\n  boxplot(iris[[i]] ~ iris$Species, ylab = names(iris)[i], xlab = \"Specie\")\n}\nprueba <- vector()\nfor(i in 1:4){\n  prueba[[i]] <- mean(iris[[i]])\n}\nprueba## [1] 5.843333 3.057333 3.758000 1.199333\nprueba <- data.frame(Especie = \"\", \n                     \"MSepal.Length\" = 0,\n                     \"SDSepal.Length\" = 0)\nprueba##   Especie MSepal.Length SDSepal.Length\n## 1                     0              0\n# c(\"setosa\", \"versicolor\", \"virginica\") = unique(iris$Species)\nfor(i in 1:3){\n  i.1 <- iris[iris$Species == unique(iris$Species)[[i]],]\n  prueba[i,] <- data.frame(Especie = as.character(unique(iris$Species)[[i]]), \n                     \"MSepal.Length\" = mean(i.1$Sepal.Length),\n                     \"SDSepal.Length\" = sd(i.1$Sepal.Length))\n}\nprueba##      Especie MSepal.Length SDSepal.Length\n## 1     setosa         5.006      0.3524897\n## 2 versicolor         5.936      0.5161711\n## 3  virginica         6.588      0.6358796\nprueba <- list()\n# c(\"setosa\", \"versicolor\", \"virginica\") = unique(iris$Species)\nfor(i in 1:3){\n  i.1 <- iris[iris$Species == unique(iris$Species)[[i]],]\n  prueba[[i]] <- data.frame(Especie = as.character(unique(iris$Species)[[i]]), \n                     \"MSepal.Length\" = mean(i.1$Sepal.Length),\n                     \"SDSepal.Length\" = sd(i.1$Sepal.Length))\n}\nprueba## [[1]]\n##   Especie MSepal.Length SDSepal.Length\n## 1  setosa         5.006      0.3524897\n## \n## [[2]]\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## [[3]]\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nprueba <- do.call(rbind, prueba)\nprueba##      Especie MSepal.Length SDSepal.Length\n## 1     setosa         5.006      0.3524897\n## 2 versicolor         5.936      0.5161711\n## 3  virginica         6.588      0.6358796"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"sapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.3 sapply()","text":"sapply trabaja con vectores o listas y las salidas usuales pueden ser matrices, con varios array, una lista o un vector, es decir, puede hacer de todo!Veamos algunas de sus aplicaciones más comunes.1. Obtener un vector numérico. Estimar la media para cada variable del conjunto de datos iris.2. Obtener una matriz con arrays que puedes transformar data.frame. Ojo el resultado de iteración lo agrega en una “columna”.Si quiero tener una salida más amigable como un data.frame tendríamos que usar otras funciones, por ejemplo:3. Obtener una lista. Se necesita que las salidas tengan dimensiones distintas, de lo contrario lo juntara en una matriz.","code":"\nsapply(1:4, function(x){mean(iris[[x]])})## [1] 5.843333 3.057333 3.758000 1.199333\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))\n  return(x.1)\n})##                [,1]                [,2]                [,3]               \n## Especie        \"setosa\"            \"versicolor\"        \"virginica\"        \n## MSepal.Length  \"5.006\"             \"5.936\"             \"6.588\"            \n## SDSepal.Length \"0.352489687213451\" \"0.516171147063863\" \"0.635879593274432\"\nlibrary(magrittr)# para usar %>%\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))\n  return(x.1)\n}) %>% as.data.frame() %>% t() %>% as.data.frame()##       Especie MSepal.Length    SDSepal.Length\n## V1     setosa         5.006 0.352489687213451\n## V2 versicolor         5.936 0.516171147063863\n## V3  virginica         6.588 0.635879593274432\nsapply(3:9, seq)## [[1]]\n## [1] 1 2 3\n## \n## [[2]]\n## [1] 1 2 3 4\n## \n## [[3]]\n## [1] 1 2 3 4 5\n## \n## [[4]]\n## [1] 1 2 3 4 5 6\n## \n## [[5]]\n## [1] 1 2 3 4 5 6 7\n## \n## [[6]]\n## [1] 1 2 3 4 5 6 7 8\n## \n## [[7]]\n## [1] 1 2 3 4 5 6 7 8 9\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  if(unique(x.1$Species) == \"setosa\"){\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length))  \n  } else {\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  }\n  \n  return(x.1)\n})## [[1]]\n##       Especie MSepal.Length \n##      \"setosa\"       \"5.006\" \n## \n## [[2]]\n##             Especie       MSepal.Length      SDSepal.Length \n##        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n## \n## [[3]]\n##             Especie       MSepal.Length      SDSepal.Length \n##         \"virginica\"             \"6.588\" \"0.635879593274432\""},{"path":"loops-en-r.-funciones-base-de-r.html","id":"tapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.4 tapply()","text":"La función tapply() aplica una función un vector x y agrupa la salida de acuerdo con un vector y del mismo largo. El vector y es categórico e idealmente debe tener distintos niveles de factor.Ejemplo.","code":"\ntapply(iris$Sepal.Width, iris$Species, mean)##     setosa versicolor  virginica \n##      3.428      2.770      2.974"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"mapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.5 mapply()","text":"La función mapply() puede ser usada bajo la misma logica de sapply pero usando más de un vector. Los vectores iteractuan por posición, es decir, el primer elemento del vector y y el vector 2, seguido del segundo elemento del vector 1 y vector 2, etc.Ejemplos:O podría hacer una función:","code":"\nmapply(mean, iris$Sepal.Length, iris$Petal.Length)##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1\n##  [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0\n##  [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5\n##  [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1\n##  [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5\n##  [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3\n## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2\n## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8\n## [145] 6.7 6.7 6.3 6.5 6.2 5.9\nmapply(sum, iris$Sepal.Length, iris$Petal.Length, iris$Sepal.Width)##   [1] 10.0  9.3  9.2  9.2 10.0 11.0  9.4  9.9  8.7  9.5 10.6  9.8  9.2  8.4 11.0\n##  [16] 11.6 10.6 10.0 11.2 10.4 10.5 10.3  9.2 10.1 10.1  9.6 10.0 10.2 10.0  9.5\n##  [31]  9.5 10.3 10.8 11.1  9.5  9.4 10.3  9.9  8.7 10.0  9.8  8.1  8.9 10.1 10.8\n##  [46]  9.2 10.5  9.2 10.5  9.7 14.9 14.1 14.9 11.8 13.9 13.0 14.3 10.6 14.1 11.8\n##  [61] 10.5 13.1 12.2 13.7 12.1 14.2 13.1 12.6 12.9 12.0 13.9 12.9 13.7 13.6 13.6\n##  [76] 14.0 14.4 14.7 13.4 11.8 11.7 11.6 12.4 13.8 12.9 13.9 14.5 13.0 12.7 12.0\n##  [91] 12.5 13.7 12.4 10.6 12.5 12.9 12.8 13.4 10.6 12.6 15.6 13.6 16.0 14.8 15.3\n## [106] 17.2 11.9 16.5 15.0 16.9 14.8 14.4 15.3 13.2 13.7 14.9 15.0 18.2 17.2 13.2\n## [121] 15.8 13.3 17.2 13.9 15.7 16.4 13.8 14.0 14.8 16.0 16.3 18.1 14.8 14.2 14.3\n## [136] 16.8 15.3 15.0 13.8 15.4 15.4 15.1 13.6 15.9 15.7 14.9 13.8 14.7 15.0 14.0\nf <- function(a,b,c) a+b/c\n\nmapply(f, iris$Sepal.Length, iris$Petal.Length, iris$Sepal.Width)##   [1]  5.500000  5.366667  5.106250  5.083871  5.388889  5.835897  5.011765\n##   [8]  5.441176  4.882759  5.383871  5.805405  5.270588  5.266667  4.666667\n##  [15]  6.100000  6.040909  5.733333  5.500000  6.147368  5.494737  5.900000\n##  [22]  5.505405  4.877778  5.615152  5.358824  5.533333  5.470588  5.628571\n##  [29]  5.611765  5.200000  5.316129  5.841176  5.565854  5.833333  5.383871\n##  [36]  5.375000  5.871429  5.288889  4.833333  5.541176  5.371429  5.065217\n##  [43]  4.806250  5.457143  5.600000  5.266667  5.521053  5.037500  5.705405\n##  [50]  5.424242  8.468750  7.806250  8.480645  7.239130  8.142857  7.307143\n##  [57]  7.724242  6.275000  8.186207  6.644444  6.750000  7.300000  7.818182\n##  [64]  7.720690  6.841379  8.119355  7.100000  7.318519  8.245455  7.160000\n##  [71]  7.400000  7.528571  8.260000  7.778571  7.882759  8.066667  8.514286\n##  [78]  8.366667  7.551724  7.046154  7.083333  7.041667  7.244444  7.888889\n##  [85]  6.900000  7.323529  8.216129  8.213043  6.966667  7.100000  7.192308\n##  [92]  7.633333  7.338462  6.434783  7.155556  7.100000  7.148276  7.682759\n##  [99]  6.300000  7.164286  8.118182  7.688889  9.066667  8.231034  8.433333\n## [106]  9.800000  6.700000  9.472414  9.020000  8.894444  8.093750  8.362963\n## [113]  8.633333  7.700000  7.621429  8.056250  8.333333  9.463158 10.353846\n## [120]  8.272727  8.681250  7.350000 10.092857  8.114815  8.427273  9.075000\n## [127]  7.914286  7.733333  8.400000  9.133333  9.578571  9.584211  8.400000\n## [134]  8.121429  8.253846  9.733333  7.947059  8.174194  7.600000  8.641935\n## [141]  8.506452  8.545161  7.688889  8.643750  8.427273  8.433333  8.300000\n## [148]  8.233333  7.788235  7.600000"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"lapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.6 lapply()","text":"La función lapply es una de las funciones más usadas en R, permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier tipo clase de R.VectorData.framePara colapsar la lista en un unico data.frame podemos usar la función .call()lista","code":"\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## [[1]]\n##             Especie       MSepal.Length      SDSepal.Length \n##            \"setosa\"             \"5.006\" \"0.352489687213451\" \n## \n## [[2]]\n##             Especie       MSepal.Length      SDSepal.Length \n##        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n## \n## [[3]]\n##             Especie       MSepal.Length      SDSepal.Length \n##         \"virginica\"             \"6.588\" \"0.635879593274432\"\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- data.frame(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## [[1]]\n##   Especie MSepal.Length SDSepal.Length\n## 1  setosa         5.006      0.3524897\n## \n## [[2]]\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## [[3]]\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- data.frame(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n}) %>% do.call(rbind, .)##      Especie MSepal.Length SDSepal.Length\n## 1     setosa         5.006      0.3524897\n## 2 versicolor         5.936      0.5161711\n## 3  virginica         6.588      0.6358796\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- list(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## [[1]]\n## [[1]]$Especie\n## [1] \"setosa\"\n## \n## [[1]]$MSepal.Length\n## [1] 5.006\n## \n## [[1]]$SDSepal.Length\n## [1] 0.3524897\n## \n## \n## [[2]]\n## [[2]]$Especie\n## [1] \"versicolor\"\n## \n## [[2]]$MSepal.Length\n## [1] 5.936\n## \n## [[2]]$SDSepal.Length\n## [1] 0.5161711\n## \n## \n## [[3]]\n## [[3]]$Especie\n## [1] \"virginica\"\n## \n## [[3]]$MSepal.Length\n## [1] 6.588\n## \n## [[3]]$SDSepal.Length\n## [1] 0.6358796"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"repeat","chapter":"5 Loops en R. Funciones base de R","heading":"5.7 repeat","text":"Repite instrucciones hasta cumplir una condición. AL cumplir la condición se rompe el loop usando break.Ejemplo.","code":"\nresultado <- vector()\ny = 1\n\nrepeat{\n  if(y > 1){\n    x <- sum(c(resultado[1:(y-1)], iris$Sepal.Length[y] + iris$Petal.Length[y]))  \n  } else {\n   x <- iris$Sepal.Length[y] + iris$Petal.Length[y]  \n  }\n  \n  if(x > 100){\n    break\n  } else {\n    resultado[[y]] <- x\n    y <- y + 1\n  }\n}"},{"path":"loops-en-r.-paquete-purrr.html","id":"loops-en-r.-paquete-purrr","chapter":"6 Loops en R. Paquete purrr","heading":"6 Loops en R. Paquete purrr","text":"El paquete purrr tiene funciones útiles para seguir implementando la programación funcional en donde la filosofía grandes rasgos es optimizar código quitando redundancia aplicando loops.https://github.com/rstudio/cheatsheets/blob/main/purrr.pdfDebemos instalar el paquete purrr:Seguiremos usando el conjunto de datos llamado iris:","code":"\ninstall.packages(\"purrr\", dependencies = TRUE)\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-paquete-purrr.html","id":"map","chapter":"6 Loops en R. Paquete purrr","heading":"6.1 map()","text":"La función map es el simil de lapply y es una de las funciones más usadas en purrr. La función permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier clase de R.Vector como iteraciónlista como iteraciónImaginemos que previamente hice un proceso donde separé las filas de cada especie y las guardé por separado en una lista.Ahora la lista tiene tres data.frames con los datos de cada especie y la usaremos como entrada en la función map. La lista tiene 3 elementos por lo que hará 3 iteraciones. En la iteración 1 tomará el primer data.frame de la lista, en la iteración 2 el segundo data.frame de la lista y en la iteración 3 tomará el tercer data.frame de la lista.Colapsar la listaYa que la lista de salida tiene data.frames con columnas con el mismo nombre podemos colapsarlos en un único data.frame usando la función .call() y rbind(), la ultima indica de que forma se puede colapsar la lista en este caso rbind indica que las apile por filas, de tal forma que las columnas se mantienen integras y lo único que incrementa son las filas.Antes es importante quitar los NULL. En ocasiones cuando algo ocurre como deseamos en lugar de dejar que falle el loop guardamos el resultado como un NULL, así sabemos que los NULL dentro de nuestra lista son errores. Por ejemplo, supongamos que queremos tener información de setosa porque sabemos que la información es incorrecta, así que aplicaremos una iteración y cuando lleguemos esa especie devolverá un NULL.Ahora antes de hacer un .call() necesitamos quitar el elemento NULL de nuestra lista. En este ejemplo es sencillo porque tenemos solo tres elementos pero imaginemos su importancia cuando tengamos docenas, cientos o miles de elementos en nuestra lista.Para quitar los NULL podemos recurrir las funciones base de R:O podemos usar la función compact de purrrTambién podríamos colapsar la lista por columnas usando la función cbind, de tal forma que la única fila que tenemos se queda integra y lo que cambia es el . de columnas.","code":"\nlibrary(purrr)## \n## Attaching package: 'purrr'## The following object is masked from 'package:magrittr':\n## \n##     set_names\nentrada <- 1:3\nmap(entrada, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## [[1]]\n##             Especie       MSepal.Length      SDSepal.Length \n##            \"setosa\"             \"5.006\" \"0.352489687213451\" \n## \n## [[2]]\n##             Especie       MSepal.Length      SDSepal.Length \n##        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n## \n## [[3]]\n##             Especie       MSepal.Length      SDSepal.Length \n##         \"virginica\"             \"6.588\" \"0.635879593274432\"\nentrada <- iris %>% split(iris$Species)\nnames(entrada)## [1] \"setosa\"     \"versicolor\" \"virginica\"\nclass(entrada)## [1] \"list\"\nejemplo <- map(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n\nejemplo## $setosa\n##   Especie MSepal.Length SDSepal.Length\n## 1  setosa         5.006      0.3524897\n## \n## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nejemplo <- map(entrada, function(x){\n  if(unique(x$Species) == \"setosa\"){\n    x.1 <- NULL\n  } else {\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))    \n  }\n  \n  return(x.1)\n})\nejemplo## $setosa\n## NULL\n## \n## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nFilter(Negate(is.null), ejemplo)## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\ncompact(ejemplo)## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nejemplo <- compact(ejemplo)\ndo.call(rbind, ejemplo)##               Especie MSepal.Length SDSepal.Length\n## versicolor versicolor         5.936      0.5161711\n## virginica   virginica         6.588      0.6358796\ndo.call(cbind, ejemplo)##   versicolor.Especie versicolor.MSepal.Length versicolor.SDSepal.Length\n## 1         versicolor                    5.936                 0.5161711\n##   virginica.Especie virginica.MSepal.Length virginica.SDSepal.Length\n## 1         virginica                   6.588                0.6358796"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfr-y-map_dfc","chapter":"6 Loops en R. Paquete purrr","heading":"6.2 map_dfr y map_dfc","text":"Para ahorrarnos el paso de usar la función .call() para colapsar las listas en un data.frame podemos usar las funciones map_dfr() y map_dfc().Es igual la función map (.e., tiene la misma estructura y trabaja con vectores, listas, arrays) pero la salida siempre es un data.frame lo que implica que en las instrucciones que aplicas en cada iteración el resultado siempre debe ser un data.frame. Si la salida es un vector numérico, un vector de caracteres, una lista, array u otra clase entonces te marcará un error.","code":""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfr","chapter":"6 Loops en R. Paquete purrr","heading":"6.2.0.1 map_dfr()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(rbind, ejemplo).\nNota. Dejaremos setosa.Usando una listaUsando un vector","code":"\nmap_dfr(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})##      Especie MSepal.Length SDSepal.Length\n## 1     setosa         5.006      0.3524897\n## 2 versicolor         5.936      0.5161711\n## 3  virginica         6.588      0.6358796\nmap_dfr(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## # A tibble: 3 x 3\n##   Especie    MSepal.Length SDSepal.Length   \n##   <chr>      <chr>         <chr>            \n## 1 setosa     5.006         0.352489687213451\n## 2 versicolor 5.936         0.516171147063863\n## 3 virginica  6.588         0.635879593274432"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfc","chapter":"6 Loops en R. Paquete purrr","heading":"6.2.1 map_dfc()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(cbind, ejemplo).Usando una listaUsando un vector¿Y si tenemos NULL de salida o un error en el proceso?","code":"\nmap_dfc(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})## New names:\n## * `Especie` -> `Especie...1`\n## * `MSepal.Length` -> `MSepal.Length...2`\n## * `SDSepal.Length` -> `SDSepal.Length...3`\n## * `Especie` -> `Especie...4`\n## * `MSepal.Length` -> `MSepal.Length...5`\n## * `SDSepal.Length` -> `SDSepal.Length...6`\n## * `Especie` -> `Especie...7`\n## * `MSepal.Length` -> `MSepal.Length...8`\n## * `SDSepal.Length` -> `SDSepal.Length...9`##   Especie...1 MSepal.Length...2 SDSepal.Length...3 Especie...4\n## 1      setosa             5.006          0.3524897  versicolor\n##   MSepal.Length...5 SDSepal.Length...6 Especie...7 MSepal.Length...8\n## 1             5.936          0.5161711   virginica             6.588\n##   SDSepal.Length...9\n## 1          0.6358796\nmap_dfc(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## New names:\n## * `` -> `...1`\n## * `` -> `...2`\n## * `` -> `...3`## # A tibble: 3 x 3\n##   ...1              ...2              ...3             \n##   <chr>             <chr>             <chr>            \n## 1 setosa            versicolor        virginica        \n## 2 5.006             5.936             6.588            \n## 3 0.352489687213451 0.516171147063863 0.635879593274432"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dbl-map_chr-y-map_lgl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3 map_dbl, map_chr y map_lgl","text":"Este grupo de funciones realiza iteraciones sobre una lista, array o vector y devuelve siempre un vector numérico (map_dbl), carácter (map_chr) o lógico (map_lgl).","code":""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dbl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.1 map_dbl()","text":"","code":"\nmap_dbl(1:4, function(x){\n  x.1 <- sqrt(mean(iris[[x]])^5)\n  return(x.1)\n})## [1] 82.537565 16.343948 27.377383  1.575251"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_chr","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.2 map_chr()","text":"","code":"\nmap_chr(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species)))\n  return(x.1)\n})##       setosa   versicolor    virginica \n##     \"setosa\" \"versicolor\"  \"virginica\""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_lgl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.3 map_lgl()","text":"","code":"\nmap_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  return(x.1)\n})##     setosa versicolor  virginica \n##       TRUE      FALSE      FALSE"},{"path":"loops-en-r.-paquete-purrr.html","id":"walk","chapter":"6 Loops en R. Paquete purrr","heading":"6.4 walk()","text":"La función Walk() es igual que map pero el resultado se muestra, es útil cuando en cada iteración guardas, gráficas imprimir algo y tienes interés en crear un objeto nuevo que gaste memoria RAM.Sería el equivalente la siguiente instrucción usando funciones base de R:","code":"\npar(mfrow=c(2,2))\nwalk(1:4, function(i){\n boxplot(iris[[i]] ~ iris$Species, ylab = names(iris)[i], xlab = \"Specie\")\n})\npar(mfrow=c(2,2))\nwalk(1:4, function(i){\n print(i)\n})## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\ninvisible(lapply(1:4, function(i){\n    print(i)\n}))## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4"},{"path":"loops-en-r.-paralelizar.html","id":"loops-en-r.-paralelizar","chapter":"7 Loops en R. Paralelizar","heading":"7 Loops en R. Paralelizar","text":"Existen diversas estrategias de paralelización y paquetes que ayudan aplicarlos en R (e.g., parallel, foreach). En esta sección usaremos el paquete future que trata de simplificar la aplicación de la paralelización en R para objetos de distintas clases. El paquete future tiene diversas estrategias de paralelización que pueden interactuar con la mayoría de las funciones y paquetes de R.Entre las estrategias principales se encuentran las siguientes:Las dos estrategias más populares son multicore y multiprocess, sin embargo, multicore solo está disponible para Linux.SecuencialMultisession vs Multicore","code":""},{"path":"loops-en-r.-paralelizar.html","id":"multisession","chapter":"7 Loops en R. Paralelizar","heading":"7.1 Multisession","text":"Paso 0. Instalar y abrir el paquete futurePaso 1. Determinar cuántos cores o workers están disponibles, en este ejemplo usaremos la función nativa del paquete future llamada availableCores():Paso 2. Correr la estrategia multisesssion usando la función plan()Paso 3. Cerrar el multisessionOpción 1Opción 2","code":"\ninstall.packages(\"future\", dependencies = TRUE)\nlibrary(future)\navailableCores()## system \n##      8\navailableCores()/2## system \n##      4\navailableCores()-2## system \n##      6\nplan(strategy = multisession, gc = TRUE, workers = 4)\nplan(sequential)\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"},{"path":"loops-en-r.-paralelizar.html","id":"paquete-furrr","chapter":"7 Loops en R. Paralelizar","heading":"7.2 Paquete furrr","text":"Seguiremos usando el conjunto de datos llamado iris:","code":"\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-paralelizar.html","id":"future_map","chapter":"7 Loops en R. Paralelizar","heading":"7.3 future_map()","text":"La función future_map es el simil de map. La función permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier clase de R.Abrimos future y furrr, y escogemos una estrategia de paralelizaciónVector como iteraciónlista como iteraciónImaginemos que previamente hice un proceso donde separé las filas de cada especie y las guardé por separado en una lista.Ahora la lista tiene tres data.frames con los datos de cada especie y la usaremos como entrada en la función future_map(). La lista tiene 3 elementos por lo que hará 3 iteraciones. En la iteración 1 tomará el primer data.frame de la lista, en la iteración 2 el segundo data.frame de la lista y en la iteración 3 tomará el tercer data.frame de la lista.Colapsar la listaYa que la lista de salida tiene data.frames con columnas con el mismo nombre podemos colapsarlos en un único data.frame usando la función .call() y rbind(), la ultima indica de que forma se puede colapsar la lista en este caso rbind indica que las apile por filas, de tal forma que las columnas se mantienen integras y lo único que incrementa son las filas.Antes es importante quitar los NULL. En ocasiones cuando algo ocurre como deseamos en lugar de dejar que falle el loop guardamos el resultado como un NULL, así sabemos que los NULL dentro de nuestra lista son errores. Por ejemplo, supongamos que queremos tener información de setosa porque sabemos que la información es incorrecta, así que aplicaremos una iteración y cuando lleguemos esa especie devolverá un NULL.Ahora antes de hacer un .call() necesitamos quitar el elemento NULL de nuestra lista. En este ejemplo es sencillo porque tenemos solo tres elementos, pero imaginemos su importancia cuando tengamos docenas, cientos o miles de elementos en nuestra lista.Para quitar los NULL podemos recurrir las funciones base de R:O podemos usar la función compact de purrrTambién podríamos colapsar la lista por columnas usando la función cbind, de tal forma que la única fila que tenemos se queda integra y lo que cambia es el . de columnas.Cerrar la paralelización","code":"\nlibrary(furrr)\nlibrary(future)\nplan(strategy = multisession, gc = TRUE, workers = 4)\nentrada <- 1:3\nfuture_map(entrada, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## [[1]]\n##             Especie       MSepal.Length      SDSepal.Length \n##            \"setosa\"             \"5.006\" \"0.352489687213451\" \n## \n## [[2]]\n##             Especie       MSepal.Length      SDSepal.Length \n##        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n## \n## [[3]]\n##             Especie       MSepal.Length      SDSepal.Length \n##         \"virginica\"             \"6.588\" \"0.635879593274432\"\nentrada <- iris %>% split(iris$Species)\nnames(entrada)## [1] \"setosa\"     \"versicolor\" \"virginica\"\nclass(entrada)## [1] \"list\"\nejemplo <- future_map(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n\nejemplo## $setosa\n##   Especie MSepal.Length SDSepal.Length\n## 1  setosa         5.006      0.3524897\n## \n## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nejemplo <- future_map(entrada, function(x){\n  if(unique(x$Species) == \"setosa\"){\n    x.1 <- NULL\n  } else {\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))    \n  }\n  \n  return(x.1)\n})\nejemplo## $setosa\n## NULL\n## \n## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nFilter(Negate(is.null), ejemplo)## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\npurrr::compact(ejemplo)## $versicolor\n##      Especie MSepal.Length SDSepal.Length\n## 1 versicolor         5.936      0.5161711\n## \n## $virginica\n##     Especie MSepal.Length SDSepal.Length\n## 1 virginica         6.588      0.6358796\nejemplo <- purrr::compact(ejemplo)\ndo.call(rbind, ejemplo)##               Especie MSepal.Length SDSepal.Length\n## versicolor versicolor         5.936      0.5161711\n## virginica   virginica         6.588      0.6358796\ndo.call(cbind, ejemplo)##   versicolor.Especie versicolor.MSepal.Length versicolor.SDSepal.Length\n## 1         versicolor                    5.936                 0.5161711\n##   virginica.Especie virginica.MSepal.Length virginica.SDSepal.Length\n## 1         virginica                   6.588                0.6358796\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"},{"path":"loops-en-r.-paralelizar.html","id":"map_dfr-y-map_dfc-1","chapter":"7 Loops en R. Paralelizar","heading":"7.4 map_dfr y map_dfc","text":"Para ahorrarnos el paso de usar la función .call() para colapsar las listas en un data.frame podemos usar las funciones future_map_dfr() y future_map_dfc().Es igual la función future_map (.e., tiene la misma estructura y trabaja con vectores, listas, arrays) pero la salida siempre es un data.frame lo que implica que en las instrucciones que aplicas en cada iteración el resultado siempre debe ser un data.frame. Si la salida es un vector numérico, un vector de caracteres, una lista, array u otra clase entonces te marcará un error.Abrimos future y furrr, y escogemos una estrategia de paralelización","code":"\nlibrary(furrr)\nlibrary(future)\nplan(strategy = multisession, gc = TRUE, workers = 4)"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dfr","chapter":"7 Loops en R. Paralelizar","heading":"7.4.0.1 future_map_dfr()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(rbind, ejemplo). Nota. Dejaremos setosa.Usando una listaUsando un vector","code":"\nfuture_map_dfr(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})##      Especie MSepal.Length SDSepal.Length\n## 1     setosa         5.006      0.3524897\n## 2 versicolor         5.936      0.5161711\n## 3  virginica         6.588      0.6358796\nfuture_map_dfr(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## # A tibble: 3 x 3\n##   Especie    MSepal.Length SDSepal.Length   \n##   <chr>      <chr>         <chr>            \n## 1 setosa     5.006         0.352489687213451\n## 2 versicolor 5.936         0.516171147063863\n## 3 virginica  6.588         0.635879593274432"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dfc","chapter":"7 Loops en R. Paralelizar","heading":"7.4.1 future_map_dfc()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(cbind, ejemplo).Usando una listaUsando un vector¿Y si tenemos NULL de salida o un error en el proceso?","code":"\nfuture_map_dfc(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})## New names:\n## * `Especie` -> `Especie...1`\n## * `MSepal.Length` -> `MSepal.Length...2`\n## * `SDSepal.Length` -> `SDSepal.Length...3`\n## * `Especie` -> `Especie...4`\n## * `MSepal.Length` -> `MSepal.Length...5`\n## * `SDSepal.Length` -> `SDSepal.Length...6`\n## * `Especie` -> `Especie...7`\n## * `MSepal.Length` -> `MSepal.Length...8`\n## * `SDSepal.Length` -> `SDSepal.Length...9`##   Especie...1 MSepal.Length...2 SDSepal.Length...3 Especie...4\n## 1      setosa             5.006          0.3524897  versicolor\n##   MSepal.Length...5 SDSepal.Length...6 Especie...7 MSepal.Length...8\n## 1             5.936          0.5161711   virginica             6.588\n##   SDSepal.Length...9\n## 1          0.6358796\nfuture_map_dfc(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})## New names:\n## * `` -> `...1`\n## * `` -> `...2`\n## * `` -> `...3`## # A tibble: 3 x 3\n##   ...1              ...2              ...3             \n##   <chr>             <chr>             <chr>            \n## 1 setosa            versicolor        virginica        \n## 2 5.006             5.936             6.588            \n## 3 0.352489687213451 0.516171147063863 0.635879593274432"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dblfuture_-map_chr-y-future_map_lgl","chapter":"7 Loops en R. Paralelizar","heading":"7.5 future_map_dbl,future_ map_chr y future_map_lgl","text":"Este grupo de funciones realiza iteraciones sobre una lista, array o vector y devuelve siempre un vector numérico (map_dbl), carácter (map_chr) o lógico (map_lgl).","code":""},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dbl","chapter":"7 Loops en R. Paralelizar","heading":"7.5.1 future_map_dbl()","text":"","code":"\nfuture_map_dbl(1:4, function(x){\n  x.1 <- sqrt(mean(iris[[x]])^5)\n  return(x.1)\n})## [1] 82.537565 16.343948 27.377383  1.575251"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_chr","chapter":"7 Loops en R. Paralelizar","heading":"7.5.2 future_map_chr()","text":"","code":"\nfuture_map_chr(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species)))\n  return(x.1)\n})##       setosa   versicolor    virginica \n##     \"setosa\" \"versicolor\"  \"virginica\""},{"path":"loops-en-r.-paralelizar.html","id":"future_map_lgl","chapter":"7 Loops en R. Paralelizar","heading":"7.5.3 future_map_lgl()","text":"","code":"\nfuture_map_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  return(x.1)\n})##     setosa versicolor  virginica \n##       TRUE      FALSE      FALSE"},{"path":"loops-en-r.-paralelizar.html","id":"incluir-una-condicional-para-detectar-posibles-errores","chapter":"7 Loops en R. Paralelizar","heading":"7.6 Incluir una condicional para detectar posibles errores","text":"Cerrar la paralelización","code":"\nprueba <- tryCatch(future_map_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  \n  if(inherits(x.1, \"error\")){\n  # Si existe un error primero cierro los sub procesos\n  a <- ps::ps()\n  a <- a[which(a$name ==\"Rscript.exe\"),1]\n  for(i in a){\n    tools::pskill(i)\n  }\n  #Despues detengo el loop\n stop(\"oh error\") \n}\n  \n  return(x.1)\n}), error = function(err)err)\n\n  if(inherits(prueba, \"error\")){\n  #Si es parte de una función sirve guardar un posible error con tryCatch\n  # Si existe un error primero cierro los sub procesos\n  a <- ps::ps()\n  a <- a[which(a$name ==\"Rscript.exe\"),1]\n  for(i in a){\n    tools::pskill(i)\n  }\n  #Despues detengo el loop\n stop(\"oh error\") \n}\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"}]
