[{"path":"index.html","id":"biodiversidades","chapter":"Biodiversidades","heading":"Biodiversidades","text":"En este manual de prueba se documenta parte del backend de Biodiversidades","code":""},{"path":"git.html","id":"git","chapter":"1 Git","heading":"1 Git","text":"","code":""},{"path":"git.html","id":"instalar-git-y-configurar","chapter":"1 Git","heading":"1.1 Instalar git y configurar","text":"1. Crear cuenta en GitLab o GitHub2. Instalar Git: https://git-scm.com/3. Abrir Git bash4. Configurar Usename escribiendo:git config –-global user.name \"tu user name\"5. Configurar correo escribiendo:git config –-global user.email \"tu user email\"6. Corroborar que se grabó el user name y correo con (Si se necesita puedes salir escribiendo laletra q y enter):git config –-list","code":""},{"path":"git.html","id":"git-gitlab-y-rstudio","chapter":"1 Git","heading":"1.2 Git, GitLab y RStudio","text":"1. Abrimos RStudio2. Nos dirigimos la pestaña de Tools -> Global options -> Git/SVN 3. Generamos una llave SSH (Solo se necesita hacer una ocasión) y la copiamos4. Abrimos GitLab y nos dirigimos Preferences o User settings -> SSH Keys 5. Pegamos el código anterior en la opción key6. Le damos un título y retiramos la fecha de expiración. /7. Finalmente, damos click en Add Key","code":""},{"path":"gitlab-github.html","id":"gitlab-github","chapter":"2 GitLab GitHub","heading":"2 GitLab GitHub","text":"","code":""},{"path":"gitlab-github.html","id":"generar-nuevo-proyecto-gitlab-o-repositorio-github","chapter":"2 GitLab GitHub","heading":"2.1 Generar nuevo proyecto (GitLab) o repositorio (GitHub)","text":"1. GitLab, crear nuevo repositorio.\nPaso 1. Crear nuevo repositorio en GitLab2. Configurar proyecto o repositorioSe deben considerar al menos 4 cosas:Nombre (obligatorio)Nombre (obligatorio)Privacidad (obligatorio)Privacidad (obligatorio)Readme (opcional)Readme (opcional)Click crear :PClick crear :PPaso 2. GitLab","code":""},{"path":"gitlab-github.html","id":"crear-proyecto-en-rstudio","chapter":"2 GitLab GitHub","heading":"2.2 Crear proyecto en RStudio","text":"1. En GitLab o GitHub debes clonar el repositorio en tu maquina haciendo Click en clone2. Copiar el código de SSH o HTTPS.3. Abrir RStudio4. Crear nuevo proyecto 5. Seleccionar Version control6. Seleccionar Git 7. Pegar en Repository URL el código SSH o HTTPS de GitLab, dar un nombre y seleccionar subdirectorio ","code":""},{"path":"gitlab-github.html","id":"push","chapter":"2 GitLab GitHub","heading":"2.3 PUSH","text":"1. Crear un nuevo archivo de R y colocar cualquier cosa, por ejemplo, crear el script de R test.REl archivo test.R aparece en la pestaña Git. Ahora daremos click en CommitSe despliega una nueva ventana. Seleccionar los archivos que se buscan subir o actualizar en el repositorio de GitLab y marcar (Stage). Escribir un mensaje (Commit message) y hacer click en Push","code":""},{"path":"gitlab-github.html","id":"pull","chapter":"2 GitLab GitHub","heading":"2.4 PULL","text":"1. Abrimos el repositorio de GitLab 2. Editamos el archivo test.R3. Hacemos un comentario en Commit messages y damos click en Commit changes4. Regresamos nuestro proyecto en RStudio y buscamos nuestra ventana con la pestaña Git que por lo general es la superior derecha.5. Damos click en Pull6. Podemos ver los cambios haciendo click en Diff o en Commit seguido de Changes:\n","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-repositorio.html","id":"organización-de-documentos-y-carpetas-en-el-repositorio","chapter":"3 Organización de documentos y carpetas en el repositorio","heading":"3 Organización de documentos y carpetas en el repositorio","text":"Este repositorio se puede usar para la generación de tablas, vectores, raster, etc. que sirven principalmente de entrada para las gráficas en la plataforma Biodiversidades.En el repositorio se incluyen entradas, scripts y salidas para el tablero de datos y el tablero geoespacial.Probablemente los usuarios más frecuentes del repositorio sean las personas que programen en la SEE, es por eso que sería de gran valía sugerir un arreglo de archivos y carpetas del repositorio. Si el repositorio y su arreglo se realiza por parte de un externo sería bueno considerar las sugerencias aquí propuestas.Se sugiere que las carpetas y archivos tengan un órden jerárquico y que los nombres de las carpetas inicien con una numeración dos dígitos y guión bajo (p. ej., 00_, 01_, 02_) seguido de nombres cortos, sin espacios y sin acentos.continuación, se enumeran algunas de las sugerencias de arreglo en repositorio:Cuatro carpetas principales, 00_Admin, 01_Entradas, 02_Scripts, 03_Salidas.La carpeta 00_Admin contiene información general que puede ser relevante para entender los archivos de entrada. Los archivos pueden ser, por ejemplo, presentaciones, metadatos de insumos, metadatos de scripts, pruebas, documentos, archivos README, etc. Debido las limitaciones de almacenamiento en los administradores de repositorios se sugiere incorporar archivos de gran tamaño; los archivos de gran tamaño pueden destinarse la carpeta de trabajo en el disco e$(\\gap) (Ver siguiente sección).La carpeta 01_Entradas contiene las subcarpetas 01_Funciones y 02_Temporales.La subcarpeta 01_Funciones contiene funciones de R (formatos: .R, .RData o .rds que se ejecutan con source()) que son usados comúnmente en los scripts de diversas secciones de la plataforma (p.ej., archivo de R que contiene las funciones de consulta al SNIB que se usan en varios indicadores). Mientras que en la subcarpeta 02_temporales se encuentran archivos temporales (archivos vectoriales, raster, tablas o funciones) que son de gran tamaño y que son de utilidad para correr de forma fluida los scripts de R. Los archivos de gran tamaño se recomienda alojarlos en la carpeta de trabajo en el disco e$(\\gap) (Ver sección 4).La carpeta 02_Scripts tiene dos subcarpetas que corresponden al Tablero de datos (01_Tablero_datos) y al Tablero geoespacial (02_Tablero_geoespacial). Dentro de cada carpeta existe un archivo .R o script (“Leader”) con las líneas de código necesarias para el procesamiento de todos los elementos/indicadores que permiten obtener las salidas para implementar los gráficos o mapas de los tableros. Para correr los scripts de los temas basta con usar la función source() (para obtener más información consultar la presentación Arreglo jerárquico).En las subcarpetas 01_Tablero_datos y 02_Tablero_geoespacial, se integran otras cuatro carpetas que corresponden los cuatro grandes temas de la plataforma BiodiversidadES (01_Conocimiento, 02_Cambio_global, 03_Avances_hacia_sustentabilidad, 04_Escenarios).La carpeta 03_Salidas contiene las salidas de los scripts de R contenidos en la carpeta 02_Scripts. Los formatos de salida serán acordados con el programador de la plataforma BriodiversidadES, sin embargo, los formatos más usuales son vectoriales, tablas e imágenes. La carpeta 03_Salidas contiene dos subcarpetas que corresponden al Tablero de datos (01_Tablero_datos) y al Tablero geoespacial (02_Tablero_geoespacial). Cada carpeta contiene cuatro carpetas que corresponden los cuatro grandes temas de la plataforma BiodiversidadES y su vez estas cuatro carpetas contienen carpetas con el nombre de las secciones.","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-repositorio.html","id":"ventajas","chapter":"3 Organización de documentos y carpetas en el repositorio","heading":"3.0.1 Ventajas","text":"Tenemos un script principal (00_Lider_) que tiene las condicionales y funciones generales guardadas en archivos .R y que se corren como sourcesTenemos un script principal (00_Lider_) que tiene las condicionales y funciones generales guardadas en archivos .R y que se corren como sourcesCada source corresponde una secciónCada source corresponde una secciónCada source tiene cientos de líneas que se pueden trabajar de forma independienteCada source tiene cientos de líneas que se pueden trabajar de forma independienteSe evita tener un único script con miles de líneas difícil de manejarSe evita tener un único script con miles de líneas difícil de manejar","code":""},{"path":"organización-de-documentos-y-carpetas-en-el-dico-duro-gap.html","id":"organización-de-documentos-y-carpetas-en-el-dico-duro-gap","chapter":"4 Organización de documentos y carpetas en el dico duro $(\\gap)","heading":"4 Organización de documentos y carpetas en el dico duro $(\\gap)","text":"En la carpeta BiodiversidadES en $(\\gap) (.e., L:\\BiodiversidadES) se incluye toda la información necesaria para correr los scripts de R albergados en el repositorio BiodiversidadES. También puede incluir documentación para entender los insumos (p.ej., archivos README)y versiones anteriores de los códigos de R. La carpeta BiodiversidadES contiene cuatro carpetas que corresponden los cuatro temas de la plataforma y su vez estas cuatro carpetas contienen carpetas con el nombre de las secciones.Cada sección tiene carpetas cuyo nombre se relaciona al formato o tipo de archivos que contiene: 01_Vectorial, 02_Raster, 03_Tabla, 04_Funciones, 05_Temporales, 06_Scripts.Ejemplo de arreglo final de carpetas en $(\\gap):NOTA. Puedes agregar más subcarpetas respetando el orden jerárquico, por ejemplo: 06_Imagenes","code":""},{"path":"loops-en-r.-funciones-base-de-r.html","id":"loops-en-r.-funciones-base-de-r","chapter":"5 Loops en R. Funciones base de R","heading":"5 Loops en R. Funciones base de R","text":"(‘“Looping”, “cycling”, “iterating” just replicating instructions’)Trabajaremos con conjunto de datos llamada iris, la base tiene información sobre el largo y ancho de sépalos y pétalos de 50 flores de tres especies de plantas.","code":"\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"apply","chapter":"5 Loops en R. Funciones base de R","heading":"5.1 apply()","text":"Aplicas instrucciones filas o columnas de un data.frame o matriz.Si queremos estimar la media de cada una de mis cuatro variables de la tabla iris entonces podría usar lo siguiente:oooPero podríamos usar apply()¿Porqué sale error o NA?Para ir tomando ritmo resolvamos los siguientes ejercicios:1) Ahora quiero la raíz cuadrada de la media que previamente es elevada la 5ta potencia2) El resultado de la raíz cuadrada la quiero multiplicar por 15 y dividir entre 23) Si el resultado es mayor 1000 que devuelva un 0","code":"\nmean(iris$Sepal.Length)\n#> [1] 5.843333\n\nmean(iris$Sepal.Width)\n#> [1] 3.057333\n\nmean(iris$Petal.Length)\n#> [1] 3.758\n\nmean(iris$Petal.Width)\n#> [1] 1.199333\nc(mean(iris$Sepal.Length), mean(iris$Sepal.Width), mean(iris$Petal.Length), mean(iris$Petal.Width))\n#> [1] 5.843333 3.057333 3.758000 1.199333\ncolMeans(iris[,1:4])\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>     5.843333     3.057333     3.758000     1.199333\napply(iris, 2, mean)\n#> Warning in mean.default(newX[, i], ...): argument is not\n#> numeric or logical: returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not\n#> numeric or logical: returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not\n#> numeric or logical: returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not\n#> numeric or logical: returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not\n#> numeric or logical: returning NA\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>           NA           NA           NA           NA \n#>      Species \n#>           NA\napply(iris[,1:4], 2, function(x){\n  x.1 <- sqrt(mean(x)^5)\n})\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>    82.537565    16.343948    27.377383     1.575251"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"for","chapter":"5 Loops en R. Funciones base de R","heading":"5.2 for()","text":"Sirve para repetir n veces una o más instrucciones. La estructura es:En el siguiente ejemplo usaremos () para obtener un boxplot para cada variable de pétalo y sépalo.Solución 1.Solución 2.Además, podemos crear vectores, listas o data.frames, pero previamente debemos crear un objeto que va almacenar nuestra salida de cada iteración (repetición de instrucciones) y que debe tener las propiedades que queremos de salida.VectorData.frameListaPara colapsar la lista en un unico objeto podemos usar la función .call()","code":"\npar(mfrow=c(2,2))\nboxplot(iris$Sepal.Length ~ iris$Species, ylab = \"Sepal.Length\",\n        xlab = \"Specie\")\nboxplot(iris$Sepal.Width ~ iris$Species, ylab = \"Sepal.Width\",\n        xlab = \"Specie\")\nboxplot(iris$Petal.Length ~ iris$Species, ylab = \"Petal.Length\",\n        xlab = \"Specie\")\nboxplot(iris$Petal.Width ~ iris$Species, ylab = \"Petal.Width\",\n        xlab = \"Specie\")\npar(mfrow=c(2,2))\nfor(i in 1:4){\n  boxplot(iris[[i]] ~ iris$Species, ylab = names(iris)[i], xlab = \"Specie\")\n}\nprueba <- vector()\nfor(i in 1:4){\n  prueba[[i]] <- mean(iris[[i]])\n}\nprueba\n#> [1] 5.843333 3.057333 3.758000 1.199333\nprueba <- data.frame(Especie = \"\", \n                     \"MSepal.Length\" = 0,\n                     \"SDSepal.Length\" = 0)\nprueba\n#>   Especie MSepal.Length SDSepal.Length\n#> 1                     0              0\n# c(\"setosa\", \"versicolor\", \"virginica\") = unique(iris$Species)\nfor(i in 1:3){\n  i.1 <- iris[iris$Species == unique(iris$Species)[[i]],]\n  prueba[i,] <- data.frame(Especie = as.character(unique(iris$Species)[[i]]), \n                     \"MSepal.Length\" = mean(i.1$Sepal.Length),\n                     \"SDSepal.Length\" = sd(i.1$Sepal.Length))\n}\nprueba\n#>      Especie MSepal.Length SDSepal.Length\n#> 1     setosa         5.006      0.3524897\n#> 2 versicolor         5.936      0.5161711\n#> 3  virginica         6.588      0.6358796\nprueba <- list()\n# c(\"setosa\", \"versicolor\", \"virginica\") = unique(iris$Species)\nfor(i in 1:3){\n  i.1 <- iris[iris$Species == unique(iris$Species)[[i]],]\n  prueba[[i]] <- data.frame(Especie = as.character(unique(iris$Species)[[i]]), \n                     \"MSepal.Length\" = mean(i.1$Sepal.Length),\n                     \"SDSepal.Length\" = sd(i.1$Sepal.Length))\n}\nprueba\n#> [[1]]\n#>   Especie MSepal.Length SDSepal.Length\n#> 1  setosa         5.006      0.3524897\n#> \n#> [[2]]\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> [[3]]\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nprueba <- do.call(rbind, prueba)\nprueba\n#>      Especie MSepal.Length SDSepal.Length\n#> 1     setosa         5.006      0.3524897\n#> 2 versicolor         5.936      0.5161711\n#> 3  virginica         6.588      0.6358796"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"sapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.3 sapply()","text":"sapply trabaja con vectores o listas y las salidas usuales pueden ser matrices, con varios array, una lista o un vector, es decir, puede hacer de todo!Veamos algunas de sus aplicaciones más comunes.1. Obtener un vector numérico. Estimar la media para cada variable del conjunto de datos iris.2. Obtener una matriz con arrays que puedes transformar data.frame. Ojo el resultado de iteración lo agrega en una “columna”.Si quiero tener una salida más amigable como un data.frame tendríamos que usar otras funciones, por ejemplo:3. Obtener una lista. Se necesita que las salidas tengan dimensiones distintas, de lo contrario lo juntara en una matriz.","code":"\nsapply(1:4, function(x){mean(iris[[x]])})\n#> [1] 5.843333 3.057333 3.758000 1.199333\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))\n  return(x.1)\n})\n#>                [,1]                [,2]               \n#> Especie        \"setosa\"            \"versicolor\"       \n#> MSepal.Length  \"5.006\"             \"5.936\"            \n#> SDSepal.Length \"0.352489687213451\" \"0.516171147063863\"\n#>                [,3]               \n#> Especie        \"virginica\"        \n#> MSepal.Length  \"6.588\"            \n#> SDSepal.Length \"0.635879593274432\"\nlibrary(magrittr)# para usar %>%\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))\n  return(x.1)\n}) %>% as.data.frame() %>% t() %>% as.data.frame()\n#>       Especie MSepal.Length    SDSepal.Length\n#> V1     setosa         5.006 0.352489687213451\n#> V2 versicolor         5.936 0.516171147063863\n#> V3  virginica         6.588 0.635879593274432\nsapply(3:9, seq)\n#> [[1]]\n#> [1] 1 2 3\n#> \n#> [[2]]\n#> [1] 1 2 3 4\n#> \n#> [[3]]\n#> [1] 1 2 3 4 5\n#> \n#> [[4]]\n#> [1] 1 2 3 4 5 6\n#> \n#> [[5]]\n#> [1] 1 2 3 4 5 6 7\n#> \n#> [[6]]\n#> [1] 1 2 3 4 5 6 7 8\n#> \n#> [[7]]\n#> [1] 1 2 3 4 5 6 7 8 9\nsapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  if(unique(x.1$Species) == \"setosa\"){\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length))  \n  } else {\n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  }\n  \n  return(x.1)\n})\n#> [[1]]\n#>       Especie MSepal.Length \n#>      \"setosa\"       \"5.006\" \n#> \n#> [[2]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n#> \n#> [[3]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>         \"virginica\"             \"6.588\" \"0.635879593274432\""},{"path":"loops-en-r.-funciones-base-de-r.html","id":"tapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.4 tapply()","text":"La función tapply() aplica una función un vector x y agrupa la salida de acuerdo con un vector y del mismo largo. El vector y es categórico e idealmente debe tener distintos niveles de factor.Ejemplo.","code":"\ntapply(iris$Sepal.Width, iris$Species, mean)\n#>     setosa versicolor  virginica \n#>      3.428      2.770      2.974"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"mapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.5 mapply()","text":"La función mapply() puede ser usada bajo la misma logica de sapply pero usando más de un vector. Los vectores iteractuan por posición, es decir, el primer elemento del vector y y el vector 2, seguido del segundo elemento del vector 1 y vector 2, etc.Ejemplos:O podría hacer una función:","code":"\nmapply(mean, iris$Sepal.Length, iris$Petal.Length)\n#>   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8\n#>  [14] 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0\n#>  [27] 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4\n#>  [40] 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4\n#>  [53] 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6\n#>  [66] 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7\n#>  [79] 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5\n#>  [92] 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3\n#> [105] 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5\n#> [118] 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2\n#> [131] 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8\n#> [144] 6.8 6.7 6.7 6.3 6.5 6.2 5.9\n\nmapply(sum, iris$Sepal.Length, iris$Petal.Length, iris$Sepal.Width)\n#>   [1] 10.0  9.3  9.2  9.2 10.0 11.0  9.4  9.9  8.7  9.5 10.6\n#>  [12]  9.8  9.2  8.4 11.0 11.6 10.6 10.0 11.2 10.4 10.5 10.3\n#>  [23]  9.2 10.1 10.1  9.6 10.0 10.2 10.0  9.5  9.5 10.3 10.8\n#>  [34] 11.1  9.5  9.4 10.3  9.9  8.7 10.0  9.8  8.1  8.9 10.1\n#>  [45] 10.8  9.2 10.5  9.2 10.5  9.7 14.9 14.1 14.9 11.8 13.9\n#>  [56] 13.0 14.3 10.6 14.1 11.8 10.5 13.1 12.2 13.7 12.1 14.2\n#>  [67] 13.1 12.6 12.9 12.0 13.9 12.9 13.7 13.6 13.6 14.0 14.4\n#>  [78] 14.7 13.4 11.8 11.7 11.6 12.4 13.8 12.9 13.9 14.5 13.0\n#>  [89] 12.7 12.0 12.5 13.7 12.4 10.6 12.5 12.9 12.8 13.4 10.6\n#> [100] 12.6 15.6 13.6 16.0 14.8 15.3 17.2 11.9 16.5 15.0 16.9\n#> [111] 14.8 14.4 15.3 13.2 13.7 14.9 15.0 18.2 17.2 13.2 15.8\n#> [122] 13.3 17.2 13.9 15.7 16.4 13.8 14.0 14.8 16.0 16.3 18.1\n#> [133] 14.8 14.2 14.3 16.8 15.3 15.0 13.8 15.4 15.4 15.1 13.6\n#> [144] 15.9 15.7 14.9 13.8 14.7 15.0 14.0\nf <- function(a,b,c) a+b/c\n\nmapply(f, iris$Sepal.Length, iris$Petal.Length, iris$Sepal.Width)\n#>   [1]  5.500000  5.366667  5.106250  5.083871  5.388889\n#>   [6]  5.835897  5.011765  5.441176  4.882759  5.383871\n#>  [11]  5.805405  5.270588  5.266667  4.666667  6.100000\n#>  [16]  6.040909  5.733333  5.500000  6.147368  5.494737\n#>  [21]  5.900000  5.505405  4.877778  5.615152  5.358824\n#>  [26]  5.533333  5.470588  5.628571  5.611765  5.200000\n#>  [31]  5.316129  5.841176  5.565854  5.833333  5.383871\n#>  [36]  5.375000  5.871429  5.288889  4.833333  5.541176\n#>  [41]  5.371429  5.065217  4.806250  5.457143  5.600000\n#>  [46]  5.266667  5.521053  5.037500  5.705405  5.424242\n#>  [51]  8.468750  7.806250  8.480645  7.239130  8.142857\n#>  [56]  7.307143  7.724242  6.275000  8.186207  6.644444\n#>  [61]  6.750000  7.300000  7.818182  7.720690  6.841379\n#>  [66]  8.119355  7.100000  7.318519  8.245455  7.160000\n#>  [71]  7.400000  7.528571  8.260000  7.778571  7.882759\n#>  [76]  8.066667  8.514286  8.366667  7.551724  7.046154\n#>  [81]  7.083333  7.041667  7.244444  7.888889  6.900000\n#>  [86]  7.323529  8.216129  8.213043  6.966667  7.100000\n#>  [91]  7.192308  7.633333  7.338462  6.434783  7.155556\n#>  [96]  7.100000  7.148276  7.682759  6.300000  7.164286\n#> [101]  8.118182  7.688889  9.066667  8.231034  8.433333\n#> [106]  9.800000  6.700000  9.472414  9.020000  8.894444\n#> [111]  8.093750  8.362963  8.633333  7.700000  7.621429\n#> [116]  8.056250  8.333333  9.463158 10.353846  8.272727\n#> [121]  8.681250  7.350000 10.092857  8.114815  8.427273\n#> [126]  9.075000  7.914286  7.733333  8.400000  9.133333\n#> [131]  9.578571  9.584211  8.400000  8.121429  8.253846\n#> [136]  9.733333  7.947059  8.174194  7.600000  8.641935\n#> [141]  8.506452  8.545161  7.688889  8.643750  8.427273\n#> [146]  8.433333  8.300000  8.233333  7.788235  7.600000"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"lapply","chapter":"5 Loops en R. Funciones base de R","heading":"5.6 lapply()","text":"La función lapply es una de las funciones más usadas en R, permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier tipo clase de R.VectorData.framePara colapsar la lista en un unico data.frame podemos usar la función .call()lista","code":"\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> [[1]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>            \"setosa\"             \"5.006\" \"0.352489687213451\" \n#> \n#> [[2]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n#> \n#> [[3]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>         \"virginica\"             \"6.588\" \"0.635879593274432\"\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- data.frame(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> [[1]]\n#>   Especie MSepal.Length SDSepal.Length\n#> 1  setosa         5.006      0.3524897\n#> \n#> [[2]]\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> [[3]]\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  x.1 <- data.frame(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n}) %>% do.call(rbind, .)\n#>      Especie MSepal.Length SDSepal.Length\n#> 1     setosa         5.006      0.3524897\n#> 2 versicolor         5.936      0.5161711\n#> 3  virginica         6.588      0.6358796\nlapply(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- list(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> [[1]]\n#> [[1]]$Especie\n#> [1] \"setosa\"\n#> \n#> [[1]]$MSepal.Length\n#> [1] 5.006\n#> \n#> [[1]]$SDSepal.Length\n#> [1] 0.3524897\n#> \n#> \n#> [[2]]\n#> [[2]]$Especie\n#> [1] \"versicolor\"\n#> \n#> [[2]]$MSepal.Length\n#> [1] 5.936\n#> \n#> [[2]]$SDSepal.Length\n#> [1] 0.5161711\n#> \n#> \n#> [[3]]\n#> [[3]]$Especie\n#> [1] \"virginica\"\n#> \n#> [[3]]$MSepal.Length\n#> [1] 6.588\n#> \n#> [[3]]$SDSepal.Length\n#> [1] 0.6358796"},{"path":"loops-en-r.-funciones-base-de-r.html","id":"repeat","chapter":"5 Loops en R. Funciones base de R","heading":"5.7 repeat","text":"Repite instrucciones hasta cumplir una condición. AL cumplir la condición se rompe el loop usando break.Ejemplo.","code":"\nresultado <- vector()\ny = 1\n\nrepeat{\n  if(y > 1){\n    x <- sum(c(resultado[1:(y-1)], iris$Sepal.Length[y] + iris$Petal.Length[y]))  \n  } else {\n   x <- iris$Sepal.Length[y] + iris$Petal.Length[y]  \n  }\n  \n  if(x > 100){\n    break\n  } else {\n    resultado[[y]] <- x\n    y <- y + 1\n  }\n}"},{"path":"loops-en-r.-paquete-purrr.html","id":"loops-en-r.-paquete-purrr","chapter":"6 Loops en R. Paquete purrr","heading":"6 Loops en R. Paquete purrr","text":"El paquete purrr tiene funciones útiles para seguir implementando la programación funcional en donde la filosofía grandes rasgos es optimizar código quitando redundancia aplicando loops.https://github.com/rstudio/cheatsheets/blob/main/purrr.pdfDebemos instalar el paquete purrr:Seguiremos usando el conjunto de datos llamado iris:","code":"\ninstall.packages(\"purrr\", dependencies = TRUE)\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-paquete-purrr.html","id":"map","chapter":"6 Loops en R. Paquete purrr","heading":"6.1 map()","text":"La función map es el simil de lapply y es una de las funciones más usadas en purrr. La función permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier clase de R.Vector como iteraciónlista como iteraciónImaginemos que previamente hice un proceso donde separé las filas de cada especie y las guardé por separado en una lista.Ahora la lista tiene tres data.frames con los datos de cada especie y la usaremos como entrada en la función map. La lista tiene 3 elementos por lo que hará 3 iteraciones. En la iteración 1 tomará el primer data.frame de la lista, en la iteración 2 el segundo data.frame de la lista y en la iteración 3 tomará el tercer data.frame de la lista.Colapsar la listaYa que la lista de salida tiene data.frames con columnas con el mismo nombre podemos colapsarlos en un único data.frame usando la función .call() y rbind(), la ultima indica de que forma se puede colapsar la lista en este caso rbind indica que las apile por filas, de tal forma que las columnas se mantienen integras y lo único que incrementa son las filas.Antes es importante quitar los NULL. En ocasiones cuando algo ocurre como deseamos en lugar de dejar que falle el loop guardamos el resultado como un NULL, así sabemos que los NULL dentro de nuestra lista son errores. Por ejemplo, supongamos que queremos tener información de setosa porque sabemos que la información es incorrecta, así que aplicaremos una iteración y cuando lleguemos esa especie devolverá un NULL.Ahora antes de hacer un .call() necesitamos quitar el elemento NULL de nuestra lista. En este ejemplo es sencillo porque tenemos solo tres elementos pero imaginemos su importancia cuando tengamos docenas, cientos o miles de elementos en nuestra lista.Para quitar los NULL podemos recurrir las funciones base de R:O podemos usar la función compact de purrrTambién podríamos colapsar la lista por columnas usando la función cbind, de tal forma que la única fila que tenemos se queda integra y lo que cambia es el . de columnas.","code":"\nlibrary(purrr)\nentrada <- 1:3\nmap(entrada, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> [[1]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>            \"setosa\"             \"5.006\" \"0.352489687213451\" \n#> \n#> [[2]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n#> \n#> [[3]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>         \"virginica\"             \"6.588\" \"0.635879593274432\"\nentrada <- iris %>% split(iris$Species)\nnames(entrada)\n#> [1] \"setosa\"     \"versicolor\" \"virginica\"\nclass(entrada)\n#> [1] \"list\"\nejemplo <- map(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n\nejemplo\n#> $setosa\n#>   Especie MSepal.Length SDSepal.Length\n#> 1  setosa         5.006      0.3524897\n#> \n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nejemplo <- map(entrada, function(x){\n  if(unique(x$Species) == \"setosa\"){\n    x.1 <- NULL\n  } else {\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))    \n  }\n  \n  return(x.1)\n})\nejemplo\n#> $setosa\n#> NULL\n#> \n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nFilter(Negate(is.null), ejemplo)\n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\ncompact(ejemplo)\n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nejemplo <- compact(ejemplo)\ndo.call(rbind, ejemplo)\n#>               Especie MSepal.Length SDSepal.Length\n#> versicolor versicolor         5.936      0.5161711\n#> virginica   virginica         6.588      0.6358796\ndo.call(cbind, ejemplo)\n#>   versicolor.Especie versicolor.MSepal.Length\n#> 1         versicolor                    5.936\n#>   versicolor.SDSepal.Length virginica.Especie\n#> 1                 0.5161711         virginica\n#>   virginica.MSepal.Length virginica.SDSepal.Length\n#> 1                   6.588                0.6358796"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfr-y-map_dfc","chapter":"6 Loops en R. Paquete purrr","heading":"6.2 map_dfr y map_dfc","text":"Para ahorrarnos el paso de usar la función .call() para colapsar las listas en un data.frame podemos usar las funciones map_dfr() y map_dfc().Es igual la función map (.e., tiene la misma estructura y trabaja con vectores, listas, arrays) pero la salida siempre es un data.frame lo que implica que en las instrucciones que aplicas en cada iteración el resultado siempre debe ser un data.frame. Si la salida es un vector numérico, un vector de caracteres, una lista, array u otra clase entonces te marcará un error.","code":""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfr","chapter":"6 Loops en R. Paquete purrr","heading":"6.2.0.1 map_dfr()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(rbind, ejemplo).\nNota. Dejaremos setosa.Usando una listaUsando un vector","code":"\nmap_dfr(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n#>      Especie MSepal.Length SDSepal.Length\n#> 1     setosa         5.006      0.3524897\n#> 2 versicolor         5.936      0.5161711\n#> 3  virginica         6.588      0.6358796\nmap_dfr(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> # A tibble: 3 x 3\n#>   Especie    MSepal.Length SDSepal.Length   \n#>   <chr>      <chr>         <chr>            \n#> 1 setosa     5.006         0.352489687213451\n#> 2 versicolor 5.936         0.516171147063863\n#> 3 virginica  6.588         0.635879593274432"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dfc","chapter":"6 Loops en R. Paquete purrr","heading":"6.2.1 map_dfc()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(cbind, ejemplo).Usando una listaUsando un vector¿Y si tenemos NULL de salida o un error en el proceso?","code":"\nmap_dfc(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n#> New names:\n#> * `Especie` -> `Especie...1`\n#> * `MSepal.Length` -> `MSepal.Length...2`\n#> * `SDSepal.Length` -> `SDSepal.Length...3`\n#> * `Especie` -> `Especie...4`\n#> * `MSepal.Length` -> `MSepal.Length...5`\n#> * `SDSepal.Length` -> `SDSepal.Length...6`\n#> * `Especie` -> `Especie...7`\n#> * `MSepal.Length` -> `MSepal.Length...8`\n#> * `SDSepal.Length` -> `SDSepal.Length...9`\n#>   Especie...1 MSepal.Length...2 SDSepal.Length...3\n#> 1      setosa             5.006          0.3524897\n#>   Especie...4 MSepal.Length...5 SDSepal.Length...6\n#> 1  versicolor             5.936          0.5161711\n#>   Especie...7 MSepal.Length...8 SDSepal.Length...9\n#> 1   virginica             6.588          0.6358796\nmap_dfc(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> New names:\n#> * `` -> `...1`\n#> * `` -> `...2`\n#> * `` -> `...3`\n#> # A tibble: 3 x 3\n#>   ...1              ...2              ...3             \n#>   <chr>             <chr>             <chr>            \n#> 1 setosa            versicolor        virginica        \n#> 2 5.006             5.936             6.588            \n#> 3 0.352489687213451 0.516171147063863 0.635879593274432"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dbl-map_chr-y-map_lgl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3 map_dbl, map_chr y map_lgl","text":"Este grupo de funciones realiza iteraciones sobre una lista, array o vector y devuelve siempre un vector numérico (map_dbl), carácter (map_chr) o lógico (map_lgl).","code":""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_dbl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.1 map_dbl()","text":"","code":"\nmap_dbl(1:4, function(x){\n  x.1 <- sqrt(mean(iris[[x]])^5)\n  return(x.1)\n})\n#> [1] 82.537565 16.343948 27.377383  1.575251"},{"path":"loops-en-r.-paquete-purrr.html","id":"map_chr","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.2 map_chr()","text":"","code":"\nmap_chr(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species)))\n  return(x.1)\n})\n#>       setosa   versicolor    virginica \n#>     \"setosa\" \"versicolor\"  \"virginica\""},{"path":"loops-en-r.-paquete-purrr.html","id":"map_lgl","chapter":"6 Loops en R. Paquete purrr","heading":"6.3.3 map_lgl()","text":"","code":"\nmap_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  return(x.1)\n})\n#>     setosa versicolor  virginica \n#>       TRUE      FALSE      FALSE"},{"path":"loops-en-r.-paquete-purrr.html","id":"walk","chapter":"6 Loops en R. Paquete purrr","heading":"6.4 walk()","text":"La función Walk() es igual que map pero el resultado se muestra, es útil cuando en cada iteración guardas, gráficas imprimir algo y tienes interés en crear un objeto nuevo que gaste memoria RAM.Sería el equivalente la siguiente instrucción usando funciones base de R:","code":"\npar(mfrow=c(2,2))\nwalk(1:4, function(i){\n boxplot(iris[[i]] ~ iris$Species, ylab = names(iris)[i], xlab = \"Specie\")\n})\npar(mfrow=c(2,2))\nwalk(1:4, function(i){\n print(i)\n})\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\ninvisible(lapply(1:4, function(i){\n    print(i)\n}))\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4"},{"path":"loops-en-r.-paralelizar.html","id":"loops-en-r.-paralelizar","chapter":"7 Loops en R. Paralelizar","heading":"7 Loops en R. Paralelizar","text":"Existen diversas estrategias de paralelización y paquetes que ayudan aplicarlos en R (e.g., parallel, foreach). En esta sección usaremos el paquete future que trata de simplificar la aplicación de la paralelización en R para objetos de distintas clases. El paquete future tiene diversas estrategias de paralelización que pueden interactuar con la mayoría de las funciones y paquetes de R.Entre las estrategias principales se encuentran las siguientes:Las dos estrategias más populares son multicore y multiprocess, sin embargo, multicore solo está disponible para Linux.SecuencialMultisession vs Multicore","code":""},{"path":"loops-en-r.-paralelizar.html","id":"multisession","chapter":"7 Loops en R. Paralelizar","heading":"7.1 Multisession","text":"Paso 0. Instalar y abrir el paquete futurePaso 1. Determinar cuántos cores o workers están disponibles, en este ejemplo usaremos la función nativa del paquete future llamada availableCores():Paso 2. Correr la estrategia multisesssion usando la función plan()Paso 3. Cerrar el multisessionOpción 1Opción 2","code":"#> \n#> Attaching package: 'magrittr'\n#> The following object is masked from 'package:purrr':\n#> \n#>     set_names\ninstall.packages(\"future\", dependencies = TRUE)\nlibrary(future)\navailableCores()\n#> system \n#>      8\n\navailableCores()/2\n#> system \n#>      4\navailableCores()-2\n#> system \n#>      6\nplan(strategy = multisession, gc = TRUE, workers = 4)\nplan(sequential)\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"},{"path":"loops-en-r.-paralelizar.html","id":"paquete-furrr","chapter":"7 Loops en R. Paralelizar","heading":"7.2 Paquete furrr","text":"Seguiremos usando el conjunto de datos llamado iris:","code":"\ndata(iris)\nDT::datatable(iris)"},{"path":"loops-en-r.-paralelizar.html","id":"future_map","chapter":"7 Loops en R. Paralelizar","heading":"7.3 future_map()","text":"La función future_map es el simil de map. La función permite realizar iteraciones sobre una lista, array o vector y devuelve siempre una lista. Esto tiene varias ventajas, por ejemplo, que puedes guardar cualquier clase de R.Abrimos future y furrr, y escogemos una estrategia de paralelizaciónVector como iteraciónlista como iteraciónImaginemos que previamente hice un proceso donde separé las filas de cada especie y las guardé por separado en una lista.Ahora la lista tiene tres data.frames con los datos de cada especie y la usaremos como entrada en la función future_map(). La lista tiene 3 elementos por lo que hará 3 iteraciones. En la iteración 1 tomará el primer data.frame de la lista, en la iteración 2 el segundo data.frame de la lista y en la iteración 3 tomará el tercer data.frame de la lista.Colapsar la listaYa que la lista de salida tiene data.frames con columnas con el mismo nombre podemos colapsarlos en un único data.frame usando la función .call() y rbind(), la ultima indica de que forma se puede colapsar la lista en este caso rbind indica que las apile por filas, de tal forma que las columnas se mantienen integras y lo único que incrementa son las filas.Antes es importante quitar los NULL. En ocasiones cuando algo ocurre como deseamos en lugar de dejar que falle el loop guardamos el resultado como un NULL, así sabemos que los NULL dentro de nuestra lista son errores. Por ejemplo, supongamos que queremos tener información de setosa porque sabemos que la información es incorrecta, así que aplicaremos una iteración y cuando lleguemos esa especie devolverá un NULL.Ahora antes de hacer un .call() necesitamos quitar el elemento NULL de nuestra lista. En este ejemplo es sencillo porque tenemos solo tres elementos, pero imaginemos su importancia cuando tengamos docenas, cientos o miles de elementos en nuestra lista.Para quitar los NULL podemos recurrir las funciones base de R:O podemos usar la función compact de purrrTambién podríamos colapsar la lista por columnas usando la función cbind, de tal forma que la única fila que tenemos se queda integra y lo que cambia es el . de columnas.Cerrar la paralelización","code":"\nlibrary(furrr)\nlibrary(future)\nplan(strategy = multisession, gc = TRUE, workers = 4)\nentrada <- 1:3\nfuture_map(entrada, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> [[1]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>            \"setosa\"             \"5.006\" \"0.352489687213451\" \n#> \n#> [[2]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>        \"versicolor\"             \"5.936\" \"0.516171147063863\" \n#> \n#> [[3]]\n#>             Especie       MSepal.Length      SDSepal.Length \n#>         \"virginica\"             \"6.588\" \"0.635879593274432\"\nentrada <- iris %>% split(iris$Species)\nnames(entrada)\n#> [1] \"setosa\"     \"versicolor\" \"virginica\"\nclass(entrada)\n#> [1] \"list\"\nejemplo <- future_map(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n\nejemplo\n#> $setosa\n#>   Especie MSepal.Length SDSepal.Length\n#> 1  setosa         5.006      0.3524897\n#> \n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nejemplo <- future_map(entrada, function(x){\n  if(unique(x$Species) == \"setosa\"){\n    x.1 <- NULL\n  } else {\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))    \n  }\n  \n  return(x.1)\n})\nejemplo\n#> $setosa\n#> NULL\n#> \n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nFilter(Negate(is.null), ejemplo)\n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\npurrr::compact(ejemplo)\n#> $versicolor\n#>      Especie MSepal.Length SDSepal.Length\n#> 1 versicolor         5.936      0.5161711\n#> \n#> $virginica\n#>     Especie MSepal.Length SDSepal.Length\n#> 1 virginica         6.588      0.6358796\nejemplo <- purrr::compact(ejemplo)\ndo.call(rbind, ejemplo)\n#>               Especie MSepal.Length SDSepal.Length\n#> versicolor versicolor         5.936      0.5161711\n#> virginica   virginica         6.588      0.6358796\ndo.call(cbind, ejemplo)\n#>   versicolor.Especie versicolor.MSepal.Length\n#> 1         versicolor                    5.936\n#>   versicolor.SDSepal.Length virginica.Especie\n#> 1                 0.5161711         virginica\n#>   virginica.MSepal.Length virginica.SDSepal.Length\n#> 1                   6.588                0.6358796\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"},{"path":"loops-en-r.-paralelizar.html","id":"map_dfr-y-map_dfc-1","chapter":"7 Loops en R. Paralelizar","heading":"7.4 map_dfr y map_dfc","text":"Para ahorrarnos el paso de usar la función .call() para colapsar las listas en un data.frame podemos usar las funciones future_map_dfr() y future_map_dfc().Es igual la función future_map (.e., tiene la misma estructura y trabaja con vectores, listas, arrays) pero la salida siempre es un data.frame lo que implica que en las instrucciones que aplicas en cada iteración el resultado siempre debe ser un data.frame. Si la salida es un vector numérico, un vector de caracteres, una lista, array u otra clase entonces te marcará un error.Abrimos future y furrr, y escogemos una estrategia de paralelización","code":"\nlibrary(furrr)\nlibrary(future)\nplan(strategy = multisession, gc = TRUE, workers = 4)"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dfr","chapter":"7 Loops en R. Paralelizar","heading":"7.4.0.1 future_map_dfr()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(rbind, ejemplo). Nota. Dejaremos setosa.Usando una listaUsando un vector","code":"\nfuture_map_dfr(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n#>      Especie MSepal.Length SDSepal.Length\n#> 1     setosa         5.006      0.3524897\n#> 2 versicolor         5.936      0.5161711\n#> 3  virginica         6.588      0.6358796\nfuture_map_dfr(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> # A tibble: 3 x 3\n#>   Especie    MSepal.Length SDSepal.Length   \n#>   <chr>      <chr>         <chr>            \n#> 1 setosa     5.006         0.352489687213451\n#> 2 versicolor 5.936         0.516171147063863\n#> 3 virginica  6.588         0.635879593274432"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dfc","chapter":"7 Loops en R. Paralelizar","heading":"7.4.1 future_map_dfc()","text":"En nuestro ejemplo anterior, esta función sustituye el .call(cbind, ejemplo).Usando una listaUsando un vector¿Y si tenemos NULL de salida o un error en el proceso?","code":"\nfuture_map_dfc(entrada, function(x){\n  x.1 <- data.frame(\"Especie\" = as.character(unique(x$Species)), \n           \"MSepal.Length\" = mean(x$Sepal.Length),\n           \"SDSepal.Length\" = sd(x$Sepal.Length))  \n  return(x.1)\n})\n#> New names:\n#> * `Especie` -> `Especie...1`\n#> * `MSepal.Length` -> `MSepal.Length...2`\n#> * `SDSepal.Length` -> `SDSepal.Length...3`\n#> * `Especie` -> `Especie...4`\n#> * `MSepal.Length` -> `MSepal.Length...5`\n#> * `SDSepal.Length` -> `SDSepal.Length...6`\n#> * `Especie` -> `Especie...7`\n#> * `MSepal.Length` -> `MSepal.Length...8`\n#> * `SDSepal.Length` -> `SDSepal.Length...9`\n#>   Especie...1 MSepal.Length...2 SDSepal.Length...3\n#> 1      setosa             5.006          0.3524897\n#>   Especie...4 MSepal.Length...5 SDSepal.Length...6\n#> 1  versicolor             5.936          0.5161711\n#>   Especie...7 MSepal.Length...8 SDSepal.Length...9\n#> 1   virginica             6.588          0.6358796\nfuture_map_dfc(1:3, function(x){\n  x.1 <- iris[iris$Species == unique(iris$Species)[[x]],]\n  \n  x.1 <- c(\"Especie\" = as.character(unique(iris$Species)[[x]]), \n           \"MSepal.Length\" = mean(x.1$Sepal.Length),\n           \"SDSepal.Length\" = sd(x.1$Sepal.Length))  \n  \n  return(x.1)\n})\n#> New names:\n#> * `` -> `...1`\n#> * `` -> `...2`\n#> * `` -> `...3`\n#> # A tibble: 3 x 3\n#>   ...1              ...2              ...3             \n#>   <chr>             <chr>             <chr>            \n#> 1 setosa            versicolor        virginica        \n#> 2 5.006             5.936             6.588            \n#> 3 0.352489687213451 0.516171147063863 0.635879593274432"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dblfuture_-map_chr-y-future_map_lgl","chapter":"7 Loops en R. Paralelizar","heading":"7.5 future_map_dbl,future_ map_chr y future_map_lgl","text":"Este grupo de funciones realiza iteraciones sobre una lista, array o vector y devuelve siempre un vector numérico (map_dbl), carácter (map_chr) o lógico (map_lgl).","code":""},{"path":"loops-en-r.-paralelizar.html","id":"future_map_dbl","chapter":"7 Loops en R. Paralelizar","heading":"7.5.1 future_map_dbl()","text":"","code":"\nfuture_map_dbl(1:4, function(x){\n  x.1 <- sqrt(mean(iris[[x]])^5)\n  return(x.1)\n})\n#> [1] 82.537565 16.343948 27.377383  1.575251"},{"path":"loops-en-r.-paralelizar.html","id":"future_map_chr","chapter":"7 Loops en R. Paralelizar","heading":"7.5.2 future_map_chr()","text":"","code":"\nfuture_map_chr(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species)))\n  return(x.1)\n})\n#>       setosa   versicolor    virginica \n#>     \"setosa\" \"versicolor\"  \"virginica\""},{"path":"loops-en-r.-paralelizar.html","id":"future_map_lgl","chapter":"7 Loops en R. Paralelizar","heading":"7.5.3 future_map_lgl()","text":"","code":"\nfuture_map_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  return(x.1)\n})\n#>     setosa versicolor  virginica \n#>       TRUE      FALSE      FALSE"},{"path":"loops-en-r.-paralelizar.html","id":"incluir-una-condicional-para-detectar-posibles-errores","chapter":"7 Loops en R. Paralelizar","heading":"7.6 Incluir una condicional para detectar posibles errores","text":"Cerrar la paralelización","code":"\nprueba <- tryCatch(future_map_lgl(entrada, function(x){\n  x.1 <- unique(as.character(unique(x$Species))) == \"setosa\"\n  \n  if(inherits(x.1, \"error\")){\n  # Si existe un error primero cierro los sub procesos\n  a <- ps::ps()\n  a <- a[which(a$name ==\"Rscript.exe\"),1]\n  for(i in a){\n    tools::pskill(i)\n  }\n  #Despues detengo el loop\n stop(\"oh error\") \n}\n  \n  return(x.1)\n}), error = function(err)err)\n\n  if(inherits(prueba, \"error\")){\n  #Si es parte de una función sirve guardar un posible error con tryCatch\n  # Si existe un error primero cierro los sub procesos\n  a <- ps::ps()\n  a <- a[which(a$name ==\"Rscript.exe\"),1]\n  for(i in a){\n    tools::pskill(i)\n  }\n  #Despues detengo el loop\n stop(\"oh error\") \n}\na <- ps::ps()\na <- a[which(a$name ==\"Rscript.exe\"),1]\n\nfor(i in a){\n  tools::pskill(i)\n}"},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"consultas-al-cat-usando-zacatuche-y-r","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8 Consultas al CAT usando zacatuche y R","text":"","code":""},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"cargar-paquetes-o-instalarlos","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.1 Cargar paquetes o instalarlos","text":"","code":"\nlist.of.packages <- c(\"stars\", \"sf\", \"raster\", \"terra\", \"rmapshaper\", \"purrr\",\n                      \"progress\", \"magrittr\", \"ghql\", \"dplyr\", \n                      \"parallel\", \"jsonlite\", \"future\", \"furrr\")\n\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages, dependencies = TRUE)\npurrr::walk(list.of.packages, function(x){suppressPackageStartupMessages(library(x, character.only = TRUE,\n                                                                                 warn.conflicts = FALSE,  quietly = TRUE))})"},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"cargar-funciones-usando-un-environment","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.2 Cargar funciones usando un environment","text":"","code":"\nload(\"L:/BiodiversidadES/01_Conocimiento/01_Diversidad_biologica/04_Funciones/CAT_SNIB_env.RData\") "},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"funciones-generales","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.3 Funciones generales","text":"","code":""},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"catalogoclass","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.3.1 CatalogoClass()","text":"La función ayuda construir los parámetros de consulta al zacatuche de forma fácil y ordenada. Si alguno de los parámetros necesarios para la consulta es incorrecto o falta, entonces mostrará un mensaje de error. Está función es usada para consultar al CAT y al SNIB ejemplares por lo que es muy importante conocer su funcionamiento y estructura.","code":"\nCAT_SNIB_ENVI$CatalogoClass(grupo_verificado = NULL,\n                            tabla = NULL,\n                            taxon = NULL,\n                            reino = NULL,\n                            categoria_taxonomica = NULL,\n                            categoria_busqueda = NULL,\n                            multiple_lista = FALSE)"},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"parámetros","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.3.1.1 Parámetros","text":"grupo_verificado = character. Grupos taxonómicos definidos con la ayuda de la SCAT de la CONABIO. Se puede elegir una de las cuatro propuestas para agrupar los táxones: “grupo1”, “grupo2”, “grupo3” o taxon y “grupo4” o reino, o seleccionar uno o varios de los táxones que se encuentran en Grupos_consulta, por ejemplo: “Hongos” o algo más especifico como “Ascomycota”.La tabla de grupos taxonómicos puede consultarse de la siguiente forma:tabla = data.frame. Una tabla con cuatro columnas, dos obligatorias: Taxon = Taxón que se consulta en el CAT; Reino = Reino al que pertenece el taxón que se consulta. Y dos opcionales: Categoría taxonómica = Categoría taxonómica del taxón que se consulta (e.g., subespecie, especie, género, familia, clase, suborden, orden); Categoría del taxon de búsqueda = Por default se entiende que se busca información nivel de especie (e.g., especies del taxón que se consulta), pero en esta columna se puede especificar si la información que se consulta se requiere otro nivel (e.g., colocar la palabra ‘género’ te devolverá información sobre los géneros del taxón que se consulta). El nombre de las columnas es importante, el orden sí.tabla = data.frame. Una tabla con cuatro columnas, dos obligatorias: Taxon = Taxón que se consulta en el CAT; Reino = Reino al que pertenece el taxón que se consulta. Y dos opcionales: Categoría taxonómica = Categoría taxonómica del taxón que se consulta (e.g., subespecie, especie, género, familia, clase, suborden, orden); Categoría del taxon de búsqueda = Por default se entiende que se busca información nivel de especie (e.g., especies del taxón que se consulta), pero en esta columna se puede especificar si la información que se consulta se requiere otro nivel (e.g., colocar la palabra ‘género’ te devolverá información sobre los géneros del taxón que se consulta). El nombre de las columnas es importante, el orden sí.taxon = character. Si solo consultas información de un grupo taxonómico puedes colocar su nombre aquí y deberás usar los tres parámetros siguientes, dos de ellos opcionales.taxon = character. Si solo consultas información de un grupo taxonómico puedes colocar su nombre aquí y deberás usar los tres parámetros siguientes, dos de ellos opcionales.reino = character. Indica el reino al que pertenece el taxón que se busca.reino = character. Indica el reino al que pertenece el taxón que se busca.categoria_taxonomica = character. Opcional, indica la categoría taxonómica del taxón que se busca, por ejemplo, subespecie, especie, género, familia, clase, suborden u orden, es decir, si mi taxon es ‘Panthera onca’ puedo especificar en esta columna que se trata de una ‘especie’.categoria_taxonomica = character. Opcional, indica la categoría taxonómica del taxón que se busca, por ejemplo, subespecie, especie, género, familia, clase, suborden u orden, es decir, si mi taxon es ‘Panthera onca’ puedo especificar en esta columna que se trata de una ‘especie’.categoria_busqueda = character. Opcional, indica la categoría taxonómica del taxón que se busca, por ejemplo, subespecie, especie, género, familia, clase, suborden u orden, es decir, si se coloca ‘género’ te devolverá información sobre los géneros del taxón que se consulta.categoria_busqueda = character. Opcional, indica la categoría taxonómica del taxón que se busca, por ejemplo, subespecie, especie, género, familia, clase, suborden u orden, es decir, si se coloca ‘género’ te devolverá información sobre los géneros del taxón que se consulta.","code":"\nCAT_SNIB_ENVI$Grupos_consulta"},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"ejemplos","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.3.1.2 Ejemplos","text":"Usando una tabla que previamente se pudo cargar con read.csv, read.table, read_csv u otras funciones. Las columnas de la table deben mantener el mismo orden que la tabla de abajo, es decir, taxón, reino, categoría taxonómica, categoría de búsqueda.En el ejemplo se busca información nivel de especie para el orden Carnivora que pertenece al reino Animalia y de la familia Fagaceae que pertenece al reino PlantaeUsando alguno de los grupos que se encuentran en la tabla Grupos_consulta (ver parámetros) y que ya fueron verificados por el SCATBuscando un solo taxón o grupo taxonómico. En los ejemplos primero se consultan las especies del orden Carnívora y después la información de la especie Tapirus bairdii.","code":"\ntabla_consulta <- data.frame(taxon = c(\"Carnivora\", \"Fagaceae\"),\n                             reino = c(\"Animalia\", \"Plantae\"),\n                             categoria_taxonomica = c(\"orden\", \"familia\"),\n                             categoria_busqueda = c(\"especie\", \"especie\"))\ntabla_consulta \n#>       taxon    reino categoria_taxonomica\n#> 1 Carnivora Animalia                orden\n#> 2  Fagaceae  Plantae              familia\n#>   categoria_busqueda\n#> 1            especie\n#> 2            especie\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(tabla = tabla_consulta)\nentrada_consulta\n#> [[1]]\n#> An object of class \"Catalogo\"\n#> Slot \"taxa\":\n#> [1] \"Carnivora AND taxonRank:especie\"\n#> \n#> Slot \"kingdom\":\n#> [1] \"Animalia\"\n#> \n#> Slot \"category\":\n#> [1] \"orden\"\n#> \n#> Slot \"gverif\":\n#> [1] \"\"\n#> \n#> \n#> [[2]]\n#> An object of class \"Catalogo\"\n#> Slot \"taxa\":\n#> [1] \"Fagaceae AND taxonRank:especie\"\n#> \n#> Slot \"kingdom\":\n#> [1] \"Plantae\"\n#> \n#> Slot \"category\":\n#> [1] \"familia\"\n#> \n#> Slot \"gverif\":\n#> [1] \"\"\n#Alguno de los grupos que ya fueron verificados\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(grupo_verificado = \"Vertebrados\")\n\nentrada_consulta[[10]]\n#> An object of class \"Catalogo\"\n#> Slot \"taxa\":\n#> [1] \"/Cetacea/ AND taxonRank:especie\"\n#> \n#> Slot \"kingdom\":\n#> [1] \"Animalia\"\n#> \n#> Slot \"category\":\n#> [1] \"orden\"\n#> \n#> Slot \"gverif\":\n#> [1] \"Vertebrados\"\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = \"Carnivora\", \n                                                reino = \"Animalia\",\n                                                categoria_taxonomica = \"orden\",\n                                                categoria_busqueda = \"especie\")\nentrada_consulta\n#> [[1]]\n#> An object of class \"Catalogo\"\n#> Slot \"taxa\":\n#> [1] \"/Carnivora/ AND taxonRank:especie\"\n#> \n#> Slot \"kingdom\":\n#> [1] \"Animalia\"\n#> \n#> Slot \"category\":\n#> [1] \"orden\"\n#> \n#> Slot \"gverif\":\n#> [1] \"\"\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = \"Tapirus bairdii\",\n                                                reino = \"Animalia\",\n                                                categoria_taxonomica = \"especie\", categoria_busqueda = \"especie\")\nentrada_consulta\n#> [[1]]\n#> An object of class \"Catalogo\"\n#> Slot \"taxa\":\n#> [1] \"/Tapirus bairdii/ AND taxonRank:especie\"\n#> \n#> Slot \"kingdom\":\n#> [1] \"Animalia\"\n#> \n#> Slot \"category\":\n#> [1] \"especie\"\n#> \n#> Slot \"gverif\":\n#> [1] \"\""},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"funciones-para-consultar-al-cat-del-snib","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.4 Funciones para consultar al CAT del SNIB","text":"La función principal es taxon_CAT y realiza la consulta al zacatuche y aplica filtros para descartar especies exóticas e invasoras, duplicados, o identificadores con NA. Estos filtros son opcionales. Los parámetros son:consulta_CAT. Clase consulta, puede ser una lista de consultas. Ver [CatalogoClass()]consulta_CAT. Clase consulta, puede ser una lista de consultas. Ver [CatalogoClass()]remover_exotica_invasora. logical, default = TRUE. Remover (TRUE) especies exóticas e invasoras de la tabla final.remover_exotica_invasora. logical, default = TRUE. Remover (TRUE) especies exóticas e invasoras de la tabla final.solo_nativas_endemicas. logical, default = FALSE. Quedarte solo con las especies marcadas como nativas y endémicas (TRUE). Se tiene el riesgo de quitar especies que han sido evaluadas y cuyo campo aparece como vacío, es decir, \"\".solo_nativas_endemicas. logical, default = FALSE. Quedarte solo con las especies marcadas como nativas y endémicas (TRUE). Se tiene el riesgo de quitar especies que han sido evaluadas y cuyo campo aparece como vacío, es decir, \"\".remover_duplicados. logical, default = TRUE. Remover (TRUE) ids validos duplicados.remover_duplicados. logical, default = TRUE. Remover (TRUE) ids validos duplicados.intern. logical, default = TRUE. Observar el progreso de la consulta.intern. logical, default = TRUE. Observar el progreso de la consulta.parallel. numeric, default = NULL. Si se quiere paralelizar entonces se debe proporcionar el número de núcleos con los que se quiere trabajar. Queda criterio del usuario para saturar la máquina.parallel. numeric, default = NULL. Si se quiere paralelizar entonces se debe proporcionar el número de núcleos con los que se quiere trabajar. Queda criterio del usuario para saturar la máquina.La función depende de las siguientes funciones:Consulta_searchTaxon: genera una consulta y un cliente (conexión graphql) para zacatuche.Consulta_searchTaxon: genera una consulta y un cliente (conexión graphql) para zacatuche.met_1: hace la consulta zacatuche GraphQL. Es apropiada para consultas que devuelvan menos de 9,000 registros del CAT.met_1: hace la consulta zacatuche GraphQL. Es apropiada para consultas que devuelvan menos de 9,000 registros del CAT.met_2: hace la consulta zacatuche GraphQL. Es apropiada para consultas que devuelvan más de 9,000 registros del CAT. Se usa un loop de tipo repeat{} y en cada iteracción se descarga un maximo de 8,000 registros para saturar Zacatuche graphQL. El repeat puede ser paralelizado.met_2: hace la consulta zacatuche GraphQL. Es apropiada para consultas que devuelvan más de 9,000 registros del CAT. Se usa un loop de tipo repeat{} y en cada iteracción se descarga un maximo de 8,000 registros para saturar Zacatuche graphQL. El repeat puede ser paralelizado.busqueda_CAT: corre la función Consulta_serachTaxon para conectarse zacatuche y consultar al CAT del SNIB y para eso corre las funciones met_1 y met_2. Si son varias consultas entonces usa un lapply() o paraleliza el proceso usando future_map() de la librería furrr.busqueda_CAT: corre la función Consulta_serachTaxon para conectarse zacatuche y consultar al CAT del SNIB y para eso corre las funciones met_1 y met_2. Si son varias consultas entonces usa un lapply() o paraleliza el proceso usando future_map() de la librería furrr.tabla_CAT: Arregla y estructura los datos en un data.frame. La salida de la consulta realizada al zacatuche es primero json y después una lista, la función tabla_CAT transforma la lista y sublistas en un data.frame y filtra la información para eliminar registros con campos vacíos, sin id, que pertenecen un Reino distinto al consultado, etc.tabla_CAT: Arregla y estructura los datos en un data.frame. La salida de la consulta realizada al zacatuche es primero json y después una lista, la función tabla_CAT transforma la lista y sublistas en un data.frame y filtra la información para eliminar registros con campos vacíos, sin id, que pertenecen un Reino distinto al consultado, etc.","code":""},{"path":"consultas-al-cat-usando-zacatuche-y-r.html","id":"ejemplos-1","chapter":"8 Consultas al CAT usando zacatuche y R","heading":"8.4.0.1 Ejemplos","text":"1. Usando una tabla que previamente se pudo cargar con read.csv, read.table, read_csv u otras funciones. Las columnas de la table deben mantener el mismo orden que la tabla de abajo, es decir, taxón, reino, categoría taxonómica, categoría de búsqueda.En el ejemplo se busca información nivel de especie para el orden Carnivora que pertenece al reino Animalia y de la familia Fagaceae que pertenece al reino PlantaeVer resultado:2. Usando alguno de los grupos que se encuentran en la tabla Grupos_consulta (ver parámetros) y que ya fueron verificados por el SCATVer resultado:3. Buscando un solo taxón o grupo taxonómico. En los ejemplos primero se consultan las especies del orden Carnívora y después la información de la especie Tapirus bairdii.","code":"\ntabla_consulta <- data.frame(taxon = c(\"Carnivora\", \"Fagaceae\"),\n                             reino = c(\"Animalia\", \"Plantae\"),\n                             categoria_taxonomica = c(\"orden\", \"familia\"),\n                             categoria_busqueda = c(\"especie\", \"especie\"))\ntabla_consulta\n#>       taxon    reino categoria_taxonomica\n#> 1 Carnivora Animalia                orden\n#> 2  Fagaceae  Plantae              familia\n#>   categoria_busqueda\n#> 1            especie\n#> 2            especie\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(tabla = tabla_consulta)\n\nresultado_consulta <- CAT_SNIB_ENVI$taxon_CAT(consulta_CAT = entrada_consulta,\n                                              remover_exotica_invasora = TRUE,\n                                              remover_duplicados = TRUE, intern = FALSE)\nresultado_consulta\n#Alguno de los grupos que ya fueron verificados\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(grupo_verificado = \"Anfibios\")\n\nresultado_consulta <- CAT_SNIB_ENVI$taxon_CAT(consulta_CAT = entrada_consulta,\n                                              remover_exotica_invasora = TRUE,\n                                              remover_duplicados = TRUE, intern = FALSE)\nresultado_consulta\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = \"Carnivora\", \n                                                reino = \"Animalia\",\n                                                categoria_taxonomica = \"orden\",\n                                                categoria_busqueda = \"especie\")\n\nCarnivoros <- CAT_SNIB_ENVI$taxon_CAT(consulta_CAT = entrada_consulta, \n                                      remover_exotica_invasora = TRUE, \n                                      remover_duplicados = TRUE)\nCarnivoros\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = \"Tapirus bairdii\", reino = \"Animalia\", categoria_taxonomica = \"especie\", categoria_busqueda = \"especie\")\n\ntapir <- CAT_SNIB_ENVI$taxon_CAT(consulta_CAT = entrada_consulta, \n                                 remover_exotica_invasora = TRUE, \n                                 remover_duplicados = TRUE)\ntapir"},{"path":"consulta-de-snib-registros-usando-zacatuche-y-r.html","id":"consulta-de-snib-registros-usando-zacatuche-y-r","chapter":"9 Consulta de SNIB registros usando zacatuche y R","heading":"9 Consulta de SNIB registros usando zacatuche y R","text":"","code":""},{"path":"consulta-de-snib-registros-usando-zacatuche-y-r.html","id":"usando-id-valido","chapter":"9 Consulta de SNIB registros usando zacatuche y R","heading":"9.1 Usando ID valido","text":"Aquí el parámetro buscar_CAT puede ser igual FALSE, es decir hace falta consultar al CAT para obtener los id validos porque previamente los obtuve","code":"\n Tapir <- tryCatch(CAT_SNIB_ENVI$taxon_coordenadas(consulta_SNIB = tapir$Valido.id,\n                                                            remover_exotica_invasora = TRUE,\n                                                            remover_duplicados = TRUE,\n                                                            filtros = list(pais = \"MEXICO\", \n                                                                           anio_min = NULL, \n                                                                           anio_max = NULL,\n                                                                           rem_novalPais = TRUE,\n                                                                           rem_novalEdo = TRUE,\n                                                                           rem_novalMun = FALSE,\n                                                                           rem_novalLoc = FALSE),\n                                                            parallel = 4,\n                                                            intern = FALSE,\n                                                            messages = FALSE,\n                                                            tabla_TipoDistribucion = TRUE,\n                                                            returnCAT = FALSE, \n                                                            buscar_CAT = FALSE,\n                                                            save_RDS = NULL), error = function(err)err)"},{"path":"consulta-de-snib-registros-usando-zacatuche-y-r.html","id":"usando-nombre-cientifico","chapter":"9 Consulta de SNIB registros usando zacatuche y R","heading":"9.2 Usando Nombre cientifico","text":"Con esta opción tenemos que dar el valor de TRUE al parámetro buscar_cat para que busqué el id valido.","code":"\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = \"Tapirus bairdii\", reino = \"Animalia\", categoria_taxonomica = \"especie\", categoria_busqueda = \"especie\")\n\n Tapir.2 <- tryCatch(CAT_SNIB_ENVI$taxon_coordenadas(consulta_SNIB = entrada_consulta,\n                                                            remover_exotica_invasora = TRUE,\n                                                            remover_duplicados = TRUE,\n                                                            filtros = list(pais = \"MEXICO\", \n                                                                           anio_min = NULL, \n                                                                           anio_max = NULL,\n                                                                           rem_novalPais = TRUE,\n                                                                           rem_novalEdo = TRUE,\n                                                                           rem_novalMun = FALSE,\n                                                                           rem_novalLoc = FALSE),\n                                                            parallel = NULL,\n                                                            intern = FALSE,\n                                                            messages = FALSE,\n                                                            tabla_TipoDistribucion = TRUE,\n                                                            returnCAT = FALSE, \n                                                            buscar_CAT = TRUE,\n                                                            save_RDS = NULL), error = function(err)err)"},{"path":"consulta-de-snib-registros-usando-zacatuche-y-r.html","id":"podemos-buscar-varias-especies","chapter":"9 Consulta de SNIB registros usando zacatuche y R","heading":"9.3 Podemos buscar varias especies","text":"","code":"\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = c(\"Tapirus bairdii\", \"Manilkara zapota\"), \n                                                reino = c(\"Animalia\", \"Plantae\"),\n                                                categoria_taxonomica = \"especie\",\n                                                categoria_busqueda = \"especie\")\n\n varios <- tryCatch(CAT_SNIB_ENVI$taxon_coordenadas(consulta_SNIB = entrada_consulta,\n                                                            remover_exotica_invasora = TRUE,\n                                                            remover_duplicados = TRUE,\n                                                            terrestres = TRUE,\n                                                            dulceacuicola = TRUE,\n                                                            marinas = FALSE,\n                                                            filtros = list(pais = \"MEXICO\", \n                                                                           anio_min = NULL, \n                                                                           anio_max = NULL,\n                                                                           rem_novalPais = TRUE,\n                                                                           rem_novalEdo = TRUE,\n                                                                           rem_novalMun = FALSE,\n                                                                           rem_novalLoc = FALSE),\n                                                            parallel = NULL,\n                                                            intern = FALSE,\n                                                            messages = FALSE,\n                                                            tabla_TipoDistribucion = TRUE,\n                                                            returnCAT = FALSE, \n                                                            buscar_CAT = TRUE,\n                                                            save_RDS = NULL), error = function(err)err)"},{"path":"consulta-de-snib-registros-usando-zacatuche-y-r.html","id":"podemos-alterar-la-busqueda","chapter":"9 Consulta de SNIB registros usando zacatuche y R","heading":"9.4 Podemos alterar la busqueda","text":"","code":"\nEjemplares_query <- CAT_SNIB_ENVI$Consulta_searchEjemplar(DATOS_URL = \"http://zacatuche2.conabio.gob.mx:4000/graphql\",\n                                                          idnombrecat = c(\"id\", \"taxon\"),\n                                                          taxonValido = c(\"id\", \"taxon\"),\n                                                          ejemplar = c(\"latitud\", \"longitud\", \"aniocolecta\", \"validacionambiente\",\n                                                                       \"geovalidacion\", \"exoticainvasora\", \"nivelprioridad\",\n                                                                       \"nom059\", \"iucn\", \"cites\", \"endemismo\",\n                                                                       \"paiscoleccion\", \"paismapa\",\n                                                                       \"especie\", \"especievalida\",\n                                                                       \"grupobio\"))\n\nentrada_consulta <- CAT_SNIB_ENVI$CatalogoClass(taxon = c(\"Tapirus bairdii\", \"Manilkara zapota\"), \n                                                reino = c(\"Animalia\", \"Plantae\"),\n                                                categoria_taxonomica = \"especie\",\n                                                categoria_busqueda = \"especie\")\n\n varios <- tryCatch(CAT_SNIB_ENVI$taxon_coordenadas(consulta_SNIB = entrada_consulta,\n                                                            remover_exotica_invasora = TRUE,\n                                                            remover_duplicados = TRUE,\n                                                            filtros = list(pais = \"MEXICO\", \n                                                                           anio_min = NULL, \n                                                                           anio_max = NULL,\n                                                                           rem_novalPais = TRUE,\n                                                                           rem_novalEdo = TRUE,\n                                                                           rem_novalMun = FALSE,\n                                                                           rem_novalLoc = FALSE),\n                                                            parallel = NULL,\n                                                            intern = FALSE,\n                                                            messages = FALSE,\n                                                            Ejemplares_query = Ejemplares_query,\n                                                            tabla_TipoDistribucion = TRUE,\n                                                            returnCAT = FALSE, \n                                                            buscar_CAT = TRUE,\n                                                            save_RDS = NULL), error = function(err)err)"}]
